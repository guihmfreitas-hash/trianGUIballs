<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trian-GUI-Balls (v3.0 - Monetization & Engagement Prototype)</title>
    <style>
        :root {
            /* Variaveis de Tema (Padr√£o) */
            --bg-color: #1a1a2e;
            --panel-bg-color: #16213e;
            --text-color: #e0e0e0;
            --accent-color: #0f3460;
            --highlight-color: #e94560;
            --neon-trail-color: #00ffff; /* Cor neon do rastro da nova vers√£o */
            --hud-bg-color: rgba(22, 33, 62, 0.85);
            --button-bg-color: #1f4068;
            --button-hover-bg-color: #275285;
            --locked-color: #4a4a4a;
            --font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
            --gem-color: #4dd0e1;
        /* Novas vari√°veis para elementos adicionais */
        --focus-pulse-color: var(--highlight-color);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
            /* A origem da transforma√ß√£o √© o centro para permitir zooms e transla√ß√µes suaves */
            transform-origin: center center;
        }

        #game-container.shake {
            animation: screen-shake 0.15s linear;
        }
        
        @keyframes screen-shake {
            0%, 100% { transform: translate(0, 0); }
            25% { transform: translate(-3px, 2px); }
            50% { transform: translate(2px, -3px); }
            75% { transform: translate(3px, 3px); }
        }


        #gameCanvas {
            background-color: transparent;
            touch-action: none;
            cursor: crosshair;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: var(--hud-bg-color);
            backdrop-filter: blur(5px);
            z-index: 10;
            font-size: 1.2rem;
            font-weight: bold;
            box-sizing: border-box;
            border-bottom: 2px solid var(--accent-color);
        }

        .hud-item {
            text-align: center;
        }
        .hud-item span {
            display: block;
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        #gem-count-hud {
            color: var(--gem-color);
        }

        /* --- NOVOS ELEMENTOS DE HUD --- */
        #combo-bar-container {
            position: relative;
            width: 120px;
            height: 12px;
            border: 2px solid var(--accent-color);
            border-radius: 6px;
            overflow: hidden;
            background-color: rgba(255, 255, 255, 0.1);
        }
        #combo-bar {
            height: 100%;
            width: 0%;
            background-color: var(--highlight-color);
            transition: width 0.15s linear;
        }
        #focus-indicator {
            display: none;
            font-size: 0.8rem;
            padding: 2px 6px;
            border: 2px solid var(--highlight-color);
            border-radius: 6px;
            white-space: nowrap;
            animation: focus-pulse 1s infinite;
        }
        @keyframes focus-pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.05); }
            100% { opacity: 1; transform: scale(1); }
        }
        #focus-indicator.active {
            display: block;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .control-button {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: bold;
            background-color: var(--button-bg-color);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s, transform 0.1s;
        }
        .control-button:hover {
            background-color: var(--button-hover-bg-color);
        }
        .control-button:active {
            transform: scale(0.95);
        }

        /* ----- PAINEL LATERAL ----- */
        #side-panel {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100%;
            background-color: var(--panel-bg-color);
            z-index: 100;
            transition: right 0.3s ease-in-out;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            border-left: 2px solid var(--accent-color);
        }
        #side-panel.open {
            right: 0;
        }

        #menu-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 101;
            background: var(--button-bg-color);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            line-height: 40px;
            text-align: center;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid var(--accent-color);
        }

        .panel-tabs {
            display: flex;
            justify-content: space-around;
            background-color: var(--accent-color);
        }
        .tab-button {
            flex-grow: 1;
            padding: 10px;
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
            border-bottom: 3px solid transparent;
            font-size: 1.2rem;
        }
        .tab-button.active {
            opacity: 1;
            border-bottom: 3px solid var(--highlight-color);
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .panel-section {
            display: none;
        }
        .panel-section.active {
            display: block;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
        }
        .grid-item {
            aspect-ratio: 1 / 1;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        .grid-item.selected {
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        .grid-item.locked {
            background-color: var(--locked-color);
            cursor: not-allowed;
            color: #888;
        }
        .grid-item.locked::after {
            content: 'üîí';
            position: absolute;
            font-size: 2rem;
            opacity: 0.7;
        }
        
        .achievement-card {
            background-color: var(--accent-color);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .achievement-card.unlocked {
            background-color: #2a522a;
        }
        .achievement-card .badge {
            font-size: 1.5rem;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid var(--accent-color);
        }

        /* ----- OVERLAYS & POPUPS ----- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 50;
            color: white;
            text-align: center;
            backdrop-filter: blur(5px);
        }

        .popup-box {
            background-color: var(--panel-bg-color);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid var(--accent-color);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 90%;
            width: 350px;
        }

        .overlay h1, .overlay h2, .popup-box h2 {
            font-size: 2.5rem;
            color: var(--highlight-color);
            text-shadow: 0 0 10px var(--highlight-color);
            margin-top: 0;
        }
        
        .overlay button, .popup-box button {
            padding: 15px 30px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            background-color: var(--button-bg-color);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            width: 80%;
        }
        .overlay button:hover, .popup-box button:hover {
            background-color: var(--button-hover-bg-color);
        }

        #watch-ad-continue-button {
             background-color: #4CAF50; /* Verde para destacar */
        }


        #pause-overlay, #game-over-screen, #daily-reward-overlay, #take-a-break-popup {
            display: none;
        }

        #toastMessage {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--highlight-color);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 200;
            transition: bottom 0.5s ease-in-out;
            font-weight: bold;
        }
        
        #combo-text {
            position: fixed;
            top: 25%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: var(--highlight-color);
            text-shadow: 0 0 15px #000, 0 0 25px var(--highlight-color);
            z-index: 200;
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            pointer-events: none;
        }
        
        #combo-text.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.2);
        }


        #achievementPopup {
            position: fixed;
            top: -150px;
            left: 50%;
            transform: translateX(-50%);
            background-color: gold;
            color: #333;
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
            text-align: center;
            border: 3px solid #ffd700;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: top 0.5s ease-in-out;
        }
        #achievementPopup h3 { margin: 0 0 5px 0; }
        #achievementPopup p { margin: 0; }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }
        
        /* ESTILOS DA LOJA E MISS√ïES */
        .mission-card {
            background-color: rgba(0,0,0,0.2);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border-left: 4px solid var(--accent-color);
        }
        .mission-card.completed {
             border-left-color: var(--gem-color);
             text-decoration: line-through;
             opacity: 0.7;
        }
        .mission-progress {
            width: 100%;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }
        .mission-progress-bar {
            width: 0%;
            height: 8px;
            background-color: var(--highlight-color);
            transition: width 0.3s;
        }
        
        .store-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--accent-color);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .store-item:hover {
            background-color: var(--button-hover-bg-color);
        }
        
    </style>
</head>
<body>
    
    <audio id="bgm-audio" loop>
        <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATEFN//tAwL1lAAAAAAAAAFlLAVaqg7e3+9//3//v/+//d//7////////3//f/+//5/+3/6//r/+v/7//////v//f//f/9//3//f/9//v/////9//3//f/+//3//f//f/9//3//f//f///+AAAAAExhdmc1OC40NQAAAAAAAaQAAAAAAAAAAAD/+9DEAAAu4w8AAAq4w8AAAAMANVXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1VV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dVV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1eJ9" type="audio/mpeg">
    </audio>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-container">
            <div class="hud-item">
                <span id="level">1</span>
                <span>N√≠vel</span>
            </div>
            <div class="hud-item">
                <span id="ball-count">1</span>
                <span>Bolas</span>
            </div>
            <div class="hud-item">
                <span id="gem-count-hud">üíé 0</span>
                <span>Gemas</span>
            </div>
            <div class="hud-item">
                <span id="highscore">0</span>
                <span>Recorde</span>
            </div>
            <!-- Nova barra de combo -->
            <div class="hud-item" style="display:flex; flex-direction:column; align-items:center; justify-content:center;">
                <div id="combo-bar-container">
                    <div id="combo-bar"></div>
                </div>
                <span style="margin-top:4px; font-size:0.7rem; opacity:0.8;">Combo</span>
            </div>
            <!-- Indicador de Modo Foco -->
            <div class="hud-item" style="display:flex; align-items:center; justify-content:center;">
                <div id="focus-indicator">MODO&nbsp;FOCO</div>
            </div>
        </div>

        <div id="controls">
            <button id="turbo-button" class="control-button">Turbo</button>
            <button id="skip-button" class="control-button">Pular</button>
        </div>

        <div id="start-screen" class="overlay">
            <h1>Trian-GUI-Balls</h1>
            <p>Arraste para mirar, solte para atirar.</p>
            <button id="start-button">Iniciar</button>
            <button id="options-button">Op√ß√µes</button>
        </div>
        
        <div id="pause-overlay" class="overlay">
            <div class="popup-box">
                <h1>Pausado</h1>
                <button id="resume-button">Continuar</button>
                <button id="restart-button-pause">Reiniciar</button>
            </div>
        </div>

        <div id="game-over-screen" class="overlay">
             <div class="popup-box">
                <h1>Fim de Jogo</h1>
                <p>Seu N√≠vel: <span id="final-level">0</span></p>
                <button id="restart-button-gameover">Jogar Novamente</button>
                <button id="watch-ad-continue-button">Continuar (Ver An√∫ncio)</button>
             </div>
        </div>
        
        <div id="daily-reward-overlay" class="overlay">
            <div class="popup-box">
                <h2>Recompensa Di√°ria!</h2>
                <p>Bem-vindo de volta! Aqui est√° seu b√¥nus por jogar hoje.</p>
                <p style="font-size: 2rem; color: var(--gem-color);">üíé 250</p>
                <button id="claim-daily-reward">Coletar!</button>
            </div>
        </div>

        <div id="take-a-break-popup" class="overlay">
            <div class="popup-box">
                <h2>Hora da Pausa!</h2>
                <p>Voc√™ √© incr√≠vel e est√° jogando muito! Que tal fazer uma pausa de 5 minutos para esticar as pernas e beber um pouco de √°gua?</p>
                <button id="close-break-popup">Ok!</button>
            </div>
        </div>


        <div id="options-overlay" class="overlay" style="display: none;">
             <div class="popup-box">
                <h2>Op√ß√µes</h2>
                <div class="config-item" style="flex-direction: column; gap: 10px;">
                    <p>Dificuldade</p>
                    <div>
                        <input type="radio" id="diff-easy" name="difficulty" value="easy"><label for="diff-easy"> F√°cil</label>
                        <input type="radio" id="diff-normal" name="difficulty" value="normal" checked><label for="diff-normal"> Normal</label>
                        <input type="radio" id="diff-hard" name="difficulty" value="hard"><label for="diff-hard"> Dif√≠cil</label>
                        <input type="radio" id="diff-insane" name="difficulty" value="insane"><label for="diff-insane"> Insana</label>
                    </div>
                </div>
                <div class="config-item">
                    <label for="sfx-toggle">Efeitos Sonoros</label>
                    <input type="checkbox" id="sfx-toggle" checked>
                </div>
                 <div class="config-item">
                    <label for="bgm-toggle">M√∫sica</label>
                    <input type="checkbox" id="bgm-toggle" checked>
                </div>
                <div class="config-item">
                    <label for="vibration-toggle">Vibra√ß√£o (Mobile)</label>
                    <input type="checkbox" id="vibration-toggle" checked>
                </div>
                <button id="save-options-button">Salvar e Reiniciar</button>
                <button id="close-options-button">Fechar</button>
             </div>
        </div>

        <div id="toastMessage">Mensagem!</div>
        <div id="combo-text">COMBO!</div>
        <div id="achievementPopup">
            <h3>üèÜ Conquista Desbloqueada! üèÜ</h3>
            <p id="achievement-text">Voc√™ √© incr√≠vel!</p>
        </div>
    </div>
    
    <button id="menu-toggle">‚ò∞</button>
    <div id="side-panel">
        <div class="panel-header">
            <h2>Menu</h2>
        </div>
        <div class="panel-tabs">
            <button class="tab-button active" data-tab="personalization">üé®</button>
            <button class="tab-button" data-tab="store-missions">üí∞</button>
            <button class="tab-button" data-tab="achievements">üèÜ</button>
            <button class="tab-button" data-tab="ranking">üìà</button>
            <button class="tab-button" data-tab="share">üîó</button>
        </div>
        <div class="panel-content">
            <div id="personalization" class="panel-section active">
                <h3>Skins de Bola</h3>
                <div id="skins-container" class="grid-container"></div>
                <h3 style="margin-top: 20px;">Temas</h3>
                <div id="themes-container" class="grid-container"></div>
            </div>
            
            <div id="store-missions" class="panel-section">
                <h3>Miss√µes Di√°rias</h3>
                <div id="missions-container"></div>
                
                <h3 style="margin-top: 20px;">Loja</h3>
                <p>Use suas gemas para comprar itens ou compre mais gemas!</p>
                <div id="store-container">
                    <div class="store-item" onclick="handlePurchase('gems_1')">
                        <span>üíé 1000 Gemas</span>
                        <span>R$ 4,99</span>
                    </div>
                    <div class="store-item" onclick="handlePurchase('gems_2')">
                        <span>üíé 5500 Gemas</span>
                        <span>R$ 20,99</span>
                    </div>
                    <div class="store-item" onclick="handlePurchase('no_ads')">
                        <span>üö´ Remover An√∫ncios</span>
                        <span>R$ 9,99</span>
                    </div>
                </div>
                <!-- Caixa Di√°ria -->
                <h3 style="margin-top: 20px;">Caixa Di√°ria</h3>
                <p>Abra uma vez por dia para ganhar recompensas aleat√≥rias.</p>
                <button id="open-daily-box" class="control-button" style="width:100%;">Abrir Caixa Di√°ria</button>
                <div id="daily-box-reward" style="margin-top:10px; min-height:20px;"></div>
            </div>

            <div id="achievements" class="panel-section">
                <h3>Conquistas (<span id="achv-count">0/100</span>)</h3>
                <div id="achievements-container"></div>
            </div>
            <div id="ranking" class="panel-section">
                <h3>Ranking Local</h3>
                <div id="ranking-container"></div>
                 <h3 style="margin-top: 20px;">Desafios</h3>
                 <p style="opacity: 0.6;">Em breve...</p>
            </div>
             <div id="share" class="panel-section">
                <h3>Compartilhar</h3>
                <p>Mostre seu recorde para seus amigos!</p>
                <button id="share-button" class="control-button" style="width: 100%;">Compartilhar Recorde</button>
            </div>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // -------------------------------------------
    // 1. SETUP INICIAL E VARI√ÅVEIS GLOBAIS
    // -------------------------------------------

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameContainer = document.getElementById('game-container');
    const ui = {
        level: document.getElementById('level'),
        ballCount: document.getElementById('ball-count'),
        highscore: document.getElementById('highscore'),
        gemCount: document.getElementById('gem-count-hud'),
        startScreen: document.getElementById('start-screen'),
        pauseOverlay: document.getElementById('pause-overlay'),
        gameOverScreen: document.getElementById('game-over-screen'),
        optionsOverlay: document.getElementById('options-overlay'),
        dailyRewardOverlay: document.getElementById('daily-reward-overlay'),
        takeABreakPopup: document.getElementById('take-a-break-popup'),
        finalLevel: document.getElementById('final-level'),
        toast: document.getElementById('toastMessage'),
        comboText: document.getElementById('combo-text'),
        achvPopup: document.getElementById('achievementPopup'),
        achvText: document.getElementById('achievement-text'),
        sidePanel: document.getElementById('side-panel'),
        menuToggle: document.getElementById('menu-toggle'),
        achvCounter: document.getElementById('achv-count')
    };
    
    const COLS = 7;
    const TARGET_AR = 9 / 16;
    const BASE_SPEED = 12;
    const ACCEL_PER_S = 0.01;
    const TURBO_MULT = 5;
    const FIRE_DELAY_MS = 80;
    const COLLISION_MARGIN = 1;
    const RANK_LIMIT = 20;
    const EXPLOSION_COLORS = ['#ff00ff', '#ff6600', '#39ff14', '#00ccff'];
    const COMBO_TIMEOUT_MS = 600; // Tempo para continuar um combo
    const BREAK_REMINDER_MS = 45 * 60 * 1000; // 45 minutos

    let gameState = {
        level: 0,
        ballCount: 1,
        balls: [],
        blocks: [],
        powerUps: [],
        particles: [],
        playerTurn: true,
        isAiming: false,
        aimStart: null,
        aimEnd: null,
        isShooting: false,
        ballsReturned: 0,
        ballsFiredThisTurn: 0,
        firstBallReturnX: null,
        isTurboActive: false,
        isPaused: false,
        isGameOver: false,
        demoMode: true,
        highScore: 0,
        difficulty: 'normal',
        // --- NOVAS VARI√ÅVEIS DE ESTADO V3.0 ---
        gems: 0,
        combo: 0,
        lastHitTime: 0,
        lastLoginDate: null,
        sessionStartTime: null,
        breakReminderShown: false,
        missions: {
            daily: []
        },
        stats: { hits: 0, blocksDestroyed: 0, bossesDefeated: 0, powerupsGreen: 0, powerdownsRed: 0, shotsFired: 0, levelsCleared: 0 },
        unlockedSkins: { 'skin_1': true },
        unlockedThemes: { 'theme_1': true },
        unlockedAchv: {},
        selectedSkin: 'skin_1',
        selectedTheme: 'theme_1',
        ranking: [],
        vibrationEnabled: true,
        sfxEnabled: true,
        bgmEnabled: true,
        // --- Vari√°veis adicionais para modos especiais e recompensas ---
        focusActive: false,
        speedMultiplier: 1,
        slowMotionActive: false,
        lastDailyBoxDate: null,
        // Escala de tempo global para efeitos como slow motion. 1 = tempo normal
        timeScale: 1,
    };
    
    let cw, ch, dpr;
    let ballRadius, blockRadius, grid;

    let lastTS = 0;
    let gameLoopId;

    const difficultyFactors = {
        easy:   { blockProb: 0.5, healthMult: 0.8, powerProb: 0.15, redProb: 0.03 },
        normal: { blockProb: 0.6, healthMult: 1.0, powerProb: 0.10, redProb: 0.05 },
        hard:   { blockProb: 0.7, healthMult: 1.3, powerProb: 0.07, redProb: 0.08 },
        insane: { blockProb: 0.8, healthMult: 1.7, powerProb: 0.05, redProb: 0.12 },
    };
    
    const MISSION_DEFINITIONS = [
        { id: 'destroy_blocks', text: 'Destrua {T} blocos', type: 'blocksDestroyed', targets: [50, 100, 200], reward: 50 },
        { id: 'defeat_bosses', text: 'Derrote {T} chefes', type: 'bossesDefeated', targets: [1, 2, 3], reward: 100 },
        { id: 'collect_green', text: 'Colete {T} power-ups verdes', type: 'powerupsGreen', targets: [5, 10, 15], reward: 75 },
        { id: 'reach_level', text: 'Alcan√ße o n√≠vel {T}', type: 'levelsCleared', targets: [10, 20, 30], reward: 150 },
    ];


    // -------------------------------------------
    // 2. CLASSES DO JOGO (COM NOVAS L√ìGICAS)
    // -------------------------------------------

    class Vector {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mul(s) { return new Vector(this.x * s, this.y * s); }
        dot(v) { return this.x * v.x + this.y * v.y; }
        mag() { return Math.hypot(this.x, this.y); }
        norm() { const m = this.mag(); return m ? this.mul(1 / m) : new Vector(); }
        rotate(angle) { const cos = Math.cos(angle); const sin = Math.sin(angle); return new Vector(this.x * cos - this.y * sin, this.x * sin + this.y * cos); }
        distanceTo(v) { return this.sub(v).mag(); }
    }
    
    class Ball { /* ... sem altera√ß√µes ... */
        constructor(pos, vel) {
            this.pos = pos;
            this.vel = vel.norm();
            this.radius = ballRadius;
            this.active = true;
            this.timeFired = performance.now();
            this.trail = [];
            this.maxTrailLength = 8;
        }
        get speed() {
            const elapsed = (performance.now() - this.timeFired) / 1000;
            const speedScale = 1 + Math.floor(gameState.level / 25) * 0.05;
            const accel = 1 + ACCEL_PER_S * elapsed;
            const turbo = gameState.isTurboActive ? TURBO_MULT : 1;
            // Multiplica pela velocidade global (acelerada ou desacelerada)
            return BASE_SPEED * speedScale * accel * turbo * gameState.speedMultiplier;
        }
        draw() {
            const trailColor = getComputedStyle(document.documentElement).getPropertyValue('--neon-trail-color').trim();
            ctx.globalAlpha = 1;
            for (let i = 0; i < this.trail.length; i++) {
                const alpha = (i + 1) / this.trail.length * 0.6;
                const radius = this.radius * (0.3 + (i + 1) / this.trail.length * 0.7);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.trail[i].x, this.trail[i].y, radius, 0, Math.PI * 2);
                ctx.fillStyle = trailColor;
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            const gradient = ctx.createRadialGradient(
                this.pos.x - this.radius / 3, this.pos.y - this.radius / 3, 0,
                this.pos.x, this.pos.y, this.radius
            );
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(1, '#ccc');
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.pos.x - this.radius / 3, this.pos.y - this.radius / 3, this.radius / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
        }
        update(dt) {
            if (!this.active) return;
            this.trail.push(new Vector(this.pos.x, this.pos.y));
            if (this.trail.length > this.maxTrailLength) this.trail.shift();

            this.pos = this.pos.add(this.vel.mul(this.speed * dt * 60));

            if (this.pos.x - this.radius < 0 || this.pos.x + this.radius > cw) {
                this.vel.x *= -1; this.pos.x = Math.max(this.radius, Math.min(cw - this.radius, this.pos.x));
                audio.playSfx('wall'); haptic.light();
            }
            if (this.pos.y - this.radius < grid.topOffset) {
                this.vel.y *= -1; this.pos.y = grid.topOffset + this.radius;
                audio.playSfx('wall'); haptic.light();
            }
            if (this.pos.y - this.radius > ch) {
                this.active = false; gameState.ballsReturned++;
                if (gameState.firstBallReturnX === null) { gameState.firstBallReturnX = this.pos.x; }
            }
        }
    }
    
    class Block {
         constructor(row, col, health) {
            this.row = row; this.col = col; this.health = health; this.maxHealth = health;
            this.sides = 3; this.radius = blockRadius;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = 0; this.pulsePhase = Math.random() * Math.PI * 2;
            this.hitAnimation = 0; this.isBoss = false;
            this.vertices = []; this.edges = [];
            this.recalculateGeometry();
        }
        recalculateGeometry() {
            this.center = new Vector((this.col + 0.5) * grid.cellW, grid.topOffset + (this.row + 0.5) * grid.gridH);
            this.generateGeometry();
        }
        generateGeometry() {
            this.vertices = []; this.edges = [];
            const pulseRadius = this.radius + Math.sin(this.pulsePhase) * 2;
            for (let i = 0; i < this.sides; i++) {
                const ang = this.rotation + (i * 2 * Math.PI) / this.sides;
                this.vertices.push(new Vector(this.center.x + pulseRadius * Math.cos(ang), this.center.y + pulseRadius * Math.sin(ang)));
            }
            for (let i = 0; i < this.sides; i++) {
                const p1 = this.vertices[i]; const p2 = this.vertices[(i + 1) % this.sides];
                const edgeVec = p2.sub(p1); const normal = new Vector(-edgeVec.y, edgeVec.x).norm();
                this.edges.push({ p1, p2, normal });
            }
        }
        hit() {
            if (this.health <= 0) return;
            this.health--; this.hitAnimation = 1; 
            
            // --- L√ìGICA DE COMBO E RECOMPENSA V3.0 ---
            const now = performance.now();
            if (now - gameState.lastHitTime < COMBO_TIMEOUT_MS) {
                gameState.combo++;
            } else {
                gameState.combo = 1;
            }
            gameState.lastHitTime = now;
            if (gameState.combo > 2) {
                showComboText(`COMBO x${gameState.combo}`);
                screenShake(0.5 + gameState.combo * 0.1);
            } else {
                 screenShake(0.5);
            }
            const gemReward = 1 + Math.floor(gameState.combo / 5);
            gameState.gems += gemReward;

            // Atualiza a barra de combo e aciona modos especiais
            updateComboBar();
            if (gameState.combo >= 6 && !gameState.focusActive) {
                activateFocusMode();
            }
            // O efeito de slowmotion agora √© aplicado apenas na destrui√ß√£o de chefes, portanto removido daqui
            
            gameState.stats.hits++;
            audio.playSfx('hit'); haptic.medium();

            if (this.health <= 0) {
                if (this.isBoss) {
                    // Destrui√ß√£o especial do chefe: aplica slow motion, zoom e dano em √°rea.
                    handleBossDestruction(this);
                    // Registra a derrota do chefe e concede recompensas adicionais
                    gameState.stats.bossesDefeated++;
                    gameState.gems += 100;
                    gameState.ballCount++;
                    showToast('+1 Bola! +100 üíé');
                    checkMissions('bossesDefeated');
                    if (Math.random() < 0.5) unlockRandomItem();
                } else {
                    // Destrui√ß√£o normal de bloco
                    spawnBlockExplosion(this.center);
                    gameState.stats.blocksDestroyed++;
                    gameState.gems += 10;
                    checkMissions('blocksDestroyed');
                }
            }
            updateHUD();
        }
        moveDown() { this.row++; this.recalculateGeometry(); }
        update(dt) {
            this.rotation += this.rotationSpeed; this.rotationSpeed *= 0.95;
            this.pulsePhase += 0.05;
            if (this.hitAnimation > 0) this.hitAnimation -= dt * 5;
            this.generateGeometry();
        }
        draw() {
            const healthRatio = this.health / this.maxHealth;
            const hue = 120 * healthRatio + 60 * (1 - healthRatio);
            const saturation = 70 + this.hitAnimation * 30;
            const lightness = 40 + this.hitAnimation * 20;
            ctx.fillStyle = `hsl(${hue},${saturation}%,${lightness}%)`;
            ctx.strokeStyle = `hsl(${hue},${saturation}%,${lightness + 20}%)`;
            ctx.lineWidth = 3;
            ctx.save(); ctx.translate(2, 2); ctx.globalAlpha = 0.3;
            ctx.beginPath(); ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            ctx.closePath(); ctx.fillStyle = '#000'; ctx.fill();
            ctx.restore();
            ctx.beginPath(); ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            const fontPx = Math.max(14, Math.round(this.radius * 0.8));
            ctx.font = `700 ${fontPx}px -apple-system, BlinkMacSystemFont, Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.health, this.center.x + 1, this.center.y + 1);
            ctx.fillStyle = '#fff';
            ctx.fillText(this.health, this.center.x, this.center.y);
        }
    }

    class BossBlock extends Block {
        constructor(row, col, health) {
            super(row, col, health);
            this.isBoss = true; this.sides = 6;
            this.radius = blockRadius * 1.5;
            this.recalculateGeometry();
        }
        hit() { super.hit(); audio.playSfx('boss'); }
    }
    
    class PowerUp { /* ... sem altera√ß√µes ... */
         constructor(row, col, isGood = true) {
            this.row = row; this.col = col; this.isGood = isGood;
            this.radius = ballRadius * 1.6; this.collected = false;
            this.rotation = 0; this.pulsePhase = Math.random() * Math.PI * 2;
            this.recalculateGeometry();
        }
        recalculateGeometry() { this.pos = new Vector((this.col + 0.5) * grid.cellW, grid.topOffset + (this.row + 0.5) * grid.gridH); }
        moveDown() { this.pos.y += grid.gridH; }
        collect() {
            if (this.collected) return; this.collected = true;
            if (this.isGood) {
                gameState.ballCount++; gameState.stats.powerupsGreen++;
                showToast('+1 Bola!'); audio.playSfx('powerup'); haptic.heavy();
                checkMissions('powerupsGreen');
            } else {
                if (gameState.ballCount > 1) {
                    gameState.ballCount--; gameState.stats.powerdownsRed++;
                    showToast('-1 Bola!', 'bad'); audio.playSfx('powerdown'); haptic.medium();
                }
            }
            updateHUD(); checkAchievements(); saveProgress();
        }
        draw() {
            if (this.collected) return;
            this.rotation += 0.05; this.pulsePhase += 0.1;
            const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
            const currentRadius = this.radius * pulse;
            const color = this.isGood ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
            const strokeColor = this.isGood ? '#0f0' : '#f00';
            const text = this.isGood ? '+' : '-';
            const gradient = ctx.createRadialGradient(this.pos.x, this.pos.y, 0, this.pos.x, this.pos.y, currentRadius * 2);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, color.replace('0.8', '0.4'));
            gradient.addColorStop(1, color.replace('0.8', '0'));
            ctx.fillStyle = gradient;
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, currentRadius * 2, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = strokeColor; ctx.lineWidth = 3; ctx.stroke();
            ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(this.rotation);
            ctx.fillStyle = strokeColor; ctx.font = `700 ${currentRadius}px -apple-system, BlinkMacSystemFont, Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }
    }

    // -------------------------------------------
    // 3. L√ìGICA DO JOGO (COM F√çSICA ATUALIZADA)
    // -------------------------------------------

    function init() {
        resizeCanvas(); 
        loadProgress(); 
        audio.init();
        setupEventListeners(); 
        renderAllSidePanelTabs();
        resetGame(); 
        
        // --- L√ìGICAS DE INICIALIZA√á√ÉO V3.0 ---
        gameState.sessionStartTime = performance.now();
        gameState.breakReminderShown = false;
        checkForDailyReward();

        gameLoop();
    }
    function resetGame(isContinue = false) {
        if (!isContinue) {
             const diffCfg = difficultyFactors[gameState.difficulty];
             gameState.level = 0; gameState.ballCount = diffCfg === difficultyFactors.easy ? 3 : 1;
             gameState.blocks = []; gameState.powerUps = []; gameState.particles = [];
             nextLevel();
        }
       
        gameState.balls = []; 
        gameState.playerTurn = true; gameState.isShooting = false; gameState.isGameOver = false; gameState.isPaused = false;
        ui.gameOverScreen.style.display = 'none';
        if (!gameState.demoMode) { ui.startScreen.style.display = 'none'; }
    }
    function gameLoop(timestamp) {
        if (!lastTS) lastTS = timestamp;
        // Calcula o delta de tempo base e aplica o escalonamento do tempo para efeitos de slow motion
        const rawDt = (timestamp - lastTS) / 1000;
        const dt = Math.min(0.05, rawDt) * (gameState.timeScale || 1);
        lastTS = timestamp;
        if (!gameState.isPaused && !gameState.isGameOver) { 
            updateAll(dt); 
            checkForBreak(); // Checa se √© hora da pausa
        }
        drawAll();
        if (gameState.demoMode && gameState.playerTurn && !gameState.isShooting) { runDemo(); }
        gameLoopId = requestAnimationFrame(gameLoop);
    }
    function updateAll(dt) {
        gameState.particles = gameState.particles.filter(p => {
            p.x += p.dx * dt * 60; p.y += p.dy * dt * 60;
            p.radius *= 0.97; p.alpha -= dt * 2;
            return p.alpha > 0 && p.radius > 0;
        });
        gameState.blocks.forEach(b => b.update(dt));
        if (gameState.isShooting) {
            const substeps = gameState.isTurboActive ? TURBO_MULT : 1;
            const subDt = dt / substeps;
            for (let i = 0; i < substeps; i++) {
                gameState.balls.forEach(ball => ball.update(subDt));
                checkCollisions();
            }
            if (gameState.ballsReturned === gameState.ballsFiredThisTurn) { endTurn(); }
        }
    }
    function endTurn() {
        gameState.isShooting = false; gameState.playerTurn = true;
        gameState.combo = 0; // Reseta o combo no final do turno
        grid.startPos.x = cw / 2; gameState.balls = [];
        nextLevel();
    }
    
    function nextLevel() {
        gameState.level++; 
        gameState.stats.levelsCleared = Math.max(gameState.stats.levelsCleared, gameState.level); // Atualiza o maior n√≠vel alcan√ßado
        checkMissions('levelsCleared');

        if (gameState.level > gameState.highScore) { gameState.highScore = gameState.level; }
        [...gameState.blocks, ...gameState.powerUps].forEach(e => e.moveDown());
        gameState.blocks = gameState.blocks.filter(b => b.center.y < ch);
        gameState.powerUps = gameState.powerUps.filter(p => p.pos.y - p.radius < ch && !p.collected);
        if (gameState.blocks.some(b => b.row >= grid.rows - 1)) { gameOver(); return; }
        generateNewRow(); updateHUD(); checkAchievements(); saveProgress();
    }
    
    function gameOver() {
        if (gameState.isGameOver) return; 
        gameState.isGameOver = true;
        ui.gameOverScreen.style.display = 'flex'; 
        ui.finalLevel.textContent = gameState.level;
        
        // N√£o cancela o game loop para a tela de fundo continuar se movendo.
        // Adiciona um prompt de nome ap√≥s um delay.
        setTimeout(() => {
            const name = prompt(`Fim de Jogo! Seu n√≠vel foi ${gameState.level}. Digite seu nome para o ranking:`, "Jogador");
            if (name) {
                gameState.ranking.push({ name, score: gameState.level });
                gameState.ranking.sort((a, b) => b.score - a.score);
                gameState.ranking = gameState.ranking.slice(0, RANK_LIMIT);
                saveProgress(); 
                renderRanking();
            }
        }, 1500);
    }
    
    // -------------------------------------------
    // 4. NOVAS FUN√á√ïES V3.0 (Engajamento e Monetiza√ß√£o)
    // -------------------------------------------
    
    function checkForDailyReward() {
        const today = new Date().toDateString();
        if (gameState.lastLoginDate !== today) {
            ui.dailyRewardOverlay.style.display = 'flex';
        }
    }

    function claimDailyReward() {
        gameState.gems += 250;
        gameState.lastLoginDate = new Date().toDateString();
        showToast('+250 üíé B√¥nus Di√°rio!');
        updateHUD();
        saveProgress();
        ui.dailyRewardOverlay.style.display = 'none';
    }

    function checkForBreak() {
        const sessionDuration = performance.now() - gameState.sessionStartTime;
        if (sessionDuration > BREAK_REMINDER_MS && !gameState.breakReminderShown) {
            gameState.breakReminderShown = true;
            ui.takeABreakPopup.style.display = 'flex';
            // Pausa o jogo
            if(!gameState.isPaused) togglePause();
        }
    }
    
    function watchAdForContinue() {
        showToast("An√∫ncio simulado... Recompensa concedida!", 'good');
        // AQUI voc√™ integraria o SDK de an√∫ncios (ex: AdMob, Unity Ads)
        // e chamaria a fun√ß√£o de recompensa no callback de sucesso do an√∫ncio.
        setTimeout(() => {
            ui.gameOverScreen.style.display = 'none';
            gameState.isGameOver = false;
            // D√™ ao jogador uma "segunda chance" limpando a primeira fileira de blocos
            gameState.blocks = gameState.blocks.filter(b => b.row > 0);
            gameState.blocks.forEach(b => {
                b.row--;
                b.recalculateGeometry();
            });
            resetGame(true); // Continua o jogo
        }, 1000);
    }
    
    function handlePurchase(itemId) {
        // AQUI voc√™ integraria o SDK de pagamentos (Google Play Billing, Apple IAP)
        console.log(`Tentativa de compra do item: ${itemId}`);
        showToast(`Fun√ß√£o de compra ainda n√£o implementada.`, 'bad');
    }
    
    function generateMissions() {
        const today = new Date().toDateString();
        // Se as miss√µes j√° foram geradas para hoje, n√£o faz nada
        if (gameState.missions.daily && gameState.missions.daily.length > 0 && gameState.missions.generatedDate === today) {
            return;
        }

        gameState.missions.daily = [];
        const availableMissions = [...MISSION_DEFINITIONS];

        for (let i = 0; i < 3; i++) {
            if (availableMissions.length === 0) break;
            const missionIndex = Math.floor(Math.random() * availableMissions.length);
            const missionDef = availableMissions.splice(missionIndex, 1)[0];
            
            const target = missionDef.targets[Math.floor(Math.random() * missionDef.targets.length)];
            const text = missionDef.text.replace('{T}', target);

            gameState.missions.daily.push({
                id: `${missionDef.id}_${target}`,
                text: text,
                type: missionDef.type,
                target: target,
                current: 0,
                reward: missionDef.reward,
                completed: false
            });
        }
        gameState.missions.generatedDate = today;
        console.log("Miss√µes di√°rias geradas:", gameState.missions.daily);
    }
    
    function checkMissions(type) {
        let missionCompleted = false;
        gameState.missions.daily.forEach(mission => {
            if (mission.type === type && !mission.completed) {
                mission.current = gameState.stats[type] || 0;
                if (mission.current >= mission.target) {
                    mission.completed = true;
                    gameState.gems += mission.reward;
                    showToast(`Miss√£o Cumprida! +${mission.reward} üíé`);
                    missionCompleted = true;
                }
            }
        });
        if (missionCompleted) {
            updateHUD();
            renderMissions();
            saveProgress();
        }
    }

    function screenShake(intensity = 1) {
        gameContainer.classList.remove('shake');
        // For√ßar reflow
        void gameContainer.offsetWidth;
        gameContainer.style.setProperty('--shake-intensity', `${intensity}px`);
        gameContainer.classList.add('shake');
        setTimeout(() => {
            if (gameContainer) gameContainer.classList.remove('shake');
        }, 150);
    }
    
    function showComboText(text) {
        ui.comboText.textContent = text;
        ui.comboText.classList.add('show');
        setTimeout(() => ui.comboText.classList.remove('show'), COMBO_TIMEOUT_MS);
    }

    // -------------------------------------------
    // Fun√ß√µes adicionais para Combo, Modo Foco, Slow Motion e Caixa Di√°ria
    // -------------------------------------------

    // Atualiza a barra de combo com base na porcentagem do combo atual (0 a 12 hits)
    function updateComboBar() {
        const bar = document.getElementById('combo-bar');
        if (!bar) return;
        const pct = Math.min(1, gameState.combo / 12);
        bar.style.width = (pct * 100) + '%';
    }

    // Ativa o modo foco: aumenta a velocidade e mostra indicador
    function activateFocusMode() {
        gameState.focusActive = true;
        // Acelera o jogo apenas se slow motion n√£o estiver ativo; se slow estiver, o slow domina
        if (!gameState.slowMotionActive) gameState.speedMultiplier = 1.3;
        // Acelera a m√∫sica de fundo se dispon√≠vel
        if (audio.bgm && typeof audio.bgm.playbackRate !== 'undefined') {
            try { audio.bgm.playbackRate = 1.3; } catch (e) {}
        }
        const indicator = document.getElementById('focus-indicator');
        if (indicator) indicator.classList.add('active');
        // Desativa modo foco ap√≥s 6 segundos
        setTimeout(() => {
            deactivateFocusMode();
        }, 6000);
    }

    function deactivateFocusMode() {
        gameState.focusActive = false;
        // Se slow motion n√£o estiver ativo, retorna velocidade ao normal
        if (!gameState.slowMotionActive) gameState.speedMultiplier = 1;
        if (audio.bgm && typeof audio.bgm.playbackRate !== 'undefined') {
            try { audio.bgm.playbackRate = 1; } catch (e) {}
        }
        const indicator = document.getElementById('focus-indicator');
        if (indicator) indicator.classList.remove('active');
    }

    // Ativa o efeito de slow motion por 0,7s
    function triggerSlowMotion() {
        gameState.slowMotionActive = true;
        // Define velocidade reduzida
        gameState.speedMultiplier = 0.4;
        setTimeout(() => {
            gameState.slowMotionActive = false;
            // Ao terminar, se ainda estiver em modo foco, volta para acelera√ß√£o; sen√£o normal
            if (gameState.focusActive) {
                gameState.speedMultiplier = 1.3;
            } else {
                gameState.speedMultiplier = 1;
            }
        }, 700);
    }

    // Fun√ß√£o para abrir a caixa di√°ria e atribuir recompensas
    function openDailyBox() {
        const today = new Date().toDateString();
        if (gameState.lastDailyBoxDate === today) {
            showToast('Voc√™ j√° abriu a caixa hoje. Volte amanh√£!', 'bad');
            return;
        }
        const rewards = [
            { type: 'gems', amount: 50 + Math.floor(Math.random() * 201) },
            { type: 'balls', amount: 1 + Math.floor(Math.random() * 2) },
            { type: 'skin' },
            { type: 'theme' }
        ];
        const reward = rewards[Math.floor(Math.random() * rewards.length)];
        let message = '';
        if (reward.type === 'gems') {
            gameState.gems += reward.amount;
            message = `+${reward.amount} üíé`;
        } else if (reward.type === 'balls') {
            gameState.ballCount += reward.amount;
            message = `+${reward.amount} Bola(s)!`;
        } else if (reward.type === 'skin') {
            const lockedSkins = SKINS.filter(s => !gameState.unlockedSkins[s.id]);
            if (lockedSkins.length > 0) {
                const skin = lockedSkins[Math.floor(Math.random() * lockedSkins.length)];
                gameState.unlockedSkins[skin.id] = true;
                message = 'Nova skin desbloqueada!';
            } else {
                const amt = 100;
                gameState.gems += amt;
                message = `+${amt} üíé`;
            }
        } else if (reward.type === 'theme') {
            const lockedThemes = THEMES.filter(t => !gameState.unlockedThemes[t.id]);
            if (lockedThemes.length > 0) {
                const theme = lockedThemes[Math.floor(Math.random() * lockedThemes.length)];
                gameState.unlockedThemes[theme.id] = true;
                message = 'Novo tema desbloqueado!';
            } else {
                const amt = 100;
                gameState.gems += amt;
                message = `+${amt} üíé`;
            }
        }
        const rewardEl = document.getElementById('daily-box-reward');
        if (rewardEl) rewardEl.textContent = message;
        showToast(message, 'good');
        gameState.lastDailyBoxDate = today;
        saveProgress();
        updateHUD();
        renderCustomization();
        renderAchievements();
    }


    // -------------------------------------------
    // 5. FUN√á√ïES DE UI E EVENTOS (ATUALIZADAS)
    // -------------------------------------------
    
    function setupEventListeners() {
        // ... (event listeners existentes)
        window.addEventListener('resize', resizeCanvas); const startAim = (e) => { if (!gameState.playerTurn || gameState.isPaused || gameState.isGameOver) return; audio.playBgm(); e.preventDefault(); gameState.isAiming = true; gameState.aimStart = getEventPos(e); }; const moveAim = (e) => { if (!gameState.isAiming) return; e.preventDefault(); gameState.aimEnd = getEventPos(e); }; const endAim = (e) => { if (!gameState.isAiming) return; e.preventDefault(); gameState.isAiming = false; const start = grid.startPos; const end = gameState.aimEnd || gameState.aimStart; if (end && end.y < start.y) { const angle = Math.atan2(end.y - start.y, end.x - start.x); fireBalls(angle); } gameState.aimEnd = null; }; canvas.addEventListener('mousedown', startAim); canvas.addEventListener('mousemove', moveAim); canvas.addEventListener('mouseup', endAim); canvas.addEventListener('mouseleave', endAim); canvas.addEventListener('touchstart', startAim, { passive: false }); canvas.addEventListener('touchmove', moveAim, { passive: false }); canvas.addEventListener('touchend', endAim); canvas.addEventListener('touchcancel', endAim); document.getElementById('start-button').addEventListener('click', () => { gameState.demoMode = false; ui.startScreen.style.display = 'none'; audio.playBgm(); resetGame(); }); const turboButton = document.getElementById('turbo-button'); turboButton.addEventListener('mousedown', () => gameState.isTurboActive = true); turboButton.addEventListener('mouseup', () => gameState.isTurboActive = false); turboButton.addEventListener('mouseleave', () => gameState.isTurboActive = false); turboButton.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.isTurboActive = true; }); turboButton.addEventListener('touchend', () => gameState.isTurboActive = false); document.getElementById('skip-button').addEventListener('click', () => { if (gameState.isShooting) endTurn(); }); document.addEventListener('keydown', (e) => { if (e.key === 'Escape' || e.key === 'p') { if (!gameState.isGameOver && ui.startScreen.style.display === 'none') togglePause(); } }); document.getElementById('resume-button').addEventListener('click', togglePause); document.getElementById('restart-button-pause').addEventListener('click', () => { togglePause(); resetGame(); }); document.getElementById('restart-button-gameover').addEventListener('click', resetGame); document.getElementById('options-button').addEventListener('click', () => ui.optionsOverlay.style.display = 'flex'); document.getElementById('close-options-button').addEventListener('click', () => ui.optionsOverlay.style.display = 'none'); document.getElementById('save-options-button').addEventListener('click', () => { gameState.difficulty = document.querySelector('input[name="difficulty"]:checked').value; gameState.sfxEnabled = document.getElementById('sfx-toggle').checked; gameState.bgmEnabled = document.getElementById('bgm-toggle').checked; gameState.vibrationEnabled = document.getElementById('vibration-toggle').checked; audio.updateVolume(); saveProgress(); ui.optionsOverlay.style.display = 'none'; resetGame(); }); ui.menuToggle.addEventListener('click', () => ui.sidePanel.classList.toggle('open')); document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => { const tabId = button.dataset.tab; document.querySelectorAll('.tab-button, .panel-section').forEach(el => el.classList.remove('active')); button.classList.add('active'); document.getElementById(tabId).classList.add('active'); }); }); document.getElementById('share-button').addEventListener('click', shareRecord);
        
        // --- NOVOS EVENT LISTENERS V3.0 ---
        document.getElementById('claim-daily-reward').addEventListener('click', claimDailyReward);
        document.getElementById('watch-ad-continue-button').addEventListener('click', watchAdForContinue);
        document.getElementById('close-break-popup').addEventListener('click', () => {
            ui.takeABreakPopup.style.display = 'none';
            if(gameState.isPaused) togglePause(); // Despausa o jogo
        });

        // Evento para abrir a caixa di√°ria
        const dailyBtn = document.getElementById('open-daily-box');
        if (dailyBtn) dailyBtn.addEventListener('click', openDailyBox);
    }
    
    function updateHUD() {
        ui.level.textContent = gameState.level;
        ui.ballCount.textContent = gameState.ballCount;
        ui.highscore.textContent = gameState.highScore;
        ui.gemCount.textContent = `üíé ${gameState.gems}`;
        // Mantenha a barra de combo sincronizada com o combo atual
        updateComboBar();
    }
    
    function renderAllSidePanelTabs() {
        renderCustomization();
        renderAchievements();
        renderRanking();
        generateMissions(); // Garante que as miss√µes sejam geradas/carregadas
        renderMissions();
    }
    
    function renderMissions() {
        const container = document.getElementById('missions-container');
        container.innerHTML = '';
        if (gameState.missions.daily.length === 0) {
            container.innerHTML = '<p>Nenhuma miss√£o hoje. Volte amanh√£!</p>';
            return;
        }

        gameState.missions.daily.forEach(mission => {
            const progress = Math.min(100, (mission.current / mission.target) * 100);
            const el = document.createElement('div');
            el.className = `mission-card ${mission.completed ? 'completed' : ''}`;
            el.innerHTML = `
                <p>${mission.text} (${mission.current}/${mission.target})</p>
                <div class="mission-progress">
                    <div class="mission-progress-bar" style="width: ${progress}%"></div>
                </div>
                <span>Recompensa: üíé ${mission.reward}</span>
            `;
            container.appendChild(el);
        });
    }
    
    // -------------------------------------------
    // 6. FUN√á√ïES DE PERSIST√äNCIA (ATUALIZADAS)
    // -------------------------------------------

    function saveProgress() {
        try {
            // Adicionando as novas vari√°veis ao objeto de progresso
            const progress = {
                highScore: gameState.highScore,
                selectedSkin: gameState.selectedSkin,
                selectedTheme: gameState.selectedTheme,
                unlockedSkins: gameState.unlockedSkins,
                unlockedThemes: gameState.unlockedThemes,
                unlockedAchv: gameState.unlockedAchv,
                vibrationEnabled: gameState.vibrationEnabled,
                sfxEnabled: gameState.sfxEnabled,
                bgmEnabled: gameState.bgmEnabled,
                difficulty: gameState.difficulty,
                stats: gameState.stats,
                ranking: gameState.ranking,
                // --- NOVOS DADOS V3.0 ---
                gems: gameState.gems,
                lastLoginDate: gameState.lastLoginDate,
                missions: gameState.missions,
                lastDailyBoxDate: gameState.lastDailyBoxDate
            };
            localStorage.setItem('trian_gui_balls_progress_v3', JSON.stringify(progress));
        } catch (e) {
            console.error("Erro ao salvar progresso:", e);
        }
    }

    function loadProgress() {
        try {
            const progressStr = localStorage.getItem('trian_gui_balls_progress_v3');
            if (progressStr) {
                const loadedProgress = JSON.parse(progressStr);
                // Usando Object.assign para mesclar o progresso salvo com o estado padr√£o,
                // garantindo que novas vari√°veis no c√≥digo n√£o quebrem o jogo.
                Object.assign(gameState, loadedProgress);
            }
            document.getElementById('vibration-toggle').checked = gameState.vibrationEnabled;
            document.getElementById('sfx-toggle').checked = gameState.sfxEnabled;
            document.getElementById('bgm-toggle').checked = gameState.bgmEnabled;
            document.querySelector(`input[name="difficulty"][value="${gameState.difficulty}"]`).checked = true;
            applyTheme(gameState.selectedTheme);
            updateHUD();
        } catch (e) {
            console.error("Erro ao carregar progresso:", e);
        }
    }


    // Fun√ß√µes restantes (sem altera√ß√µes significativas)
    function togglePause() { gameState.isPaused = !gameState.isPaused; ui.pauseOverlay.style.display = gameState.isPaused ? 'flex' : 'none'; if (!gameState.isPaused) { lastTS = performance.now(); gameLoop(lastTS); audio.playBgm(); } else { cancelAnimationFrame(gameLoopId); if(audio.bgm) audio.bgm.pause(); } }
    function fireBalls(angle) { if (!gameState.playerTurn || gameState.isShooting) return; gameState.playerTurn = false; gameState.isShooting = true; gameState.ballsReturned = 0; gameState.ballsFiredThisTurn = gameState.ballCount; gameState.firstBallReturnX = null; gameState.stats.shotsFired++; const vel = new Vector(Math.cos(angle), Math.sin(angle)); for (let i = 0; i < gameState.ballCount; i++) { setTimeout(() => { if (gameState.isGameOver || gameState.isPaused) return; gameState.balls.push(new Ball(new Vector(grid.startPos.x, grid.startPos.y), vel)); }, i * FIRE_DELAY_MS); } }
    function checkCollisions() { for (const ball of gameState.balls) { if (!ball.active) continue; for (const p of gameState.powerUps) { if (!p.collected && ball.pos.distanceTo(p.pos) < ball.radius + p.radius) { p.collect(); } } gameState.powerUps = gameState.powerUps.filter(p => !p.collected); for (const block of gameState.blocks) { if (ball.pos.distanceTo(block.center) > ball.radius + block.radius * 1.5) continue; for (const edge of block.edges) { const lineVec = edge.p2.sub(edge.p1); const pointVec = ball.pos.sub(edge.p1); const t = clamp(pointVec.dot(lineVec) / lineVec.dot(lineVec), 0, 1); const closestPoint = edge.p1.add(lineVec.mul(t)); const distVec = ball.pos.sub(closestPoint); const distance = distVec.mag(); if (distance < ball.radius + COLLISION_MARGIN) { block.hit(); if (!block.isBoss) { const spin = ball.vel.x * edge.normal.y - ball.vel.y * edge.normal.x; const direction = spin >= 0 ? 1 : -1; const relVec = closestPoint.sub(block.center); const torque = Math.min(1, relVec.mag() / block.radius); block.rotationSpeed += torque * 0.15 * direction; } const dot = ball.vel.dot(edge.normal); ball.vel = ball.vel.sub(edge.normal.mul(2 * dot)).norm(); const overlap = ball.radius + COLLISION_MARGIN - distance; const pushDir = distance > 0 ? distVec.norm() : edge.normal; ball.pos = ball.pos.add(pushDir.mul(overlap + 0.5)); goto_next_ball_check:; } } } gameState.blocks = gameState.blocks.filter(b => b.health > 0); } }
    function spawnBlockExplosion(position) { const count = 12; for (let i = 0; i < count; i++) { const angle = Math.random() * Math.PI * 2; const speed = 2 + Math.random() * 2; const dx = Math.cos(angle) * speed; const dy = Math.sin(angle) * speed; const radius = 3 + Math.random() * 3; const color = EXPLOSION_COLORS[Math.floor(Math.random() * EXPLOSION_COLORS.length)]; gameState.particles.push({ x: position.x, y: position.y, dx, dy, radius, alpha: 1, color }); } }
    
    /**
     * Aplica um zoom e transla√ß√£o no container do jogo para dar close em um ponto espec√≠fico.
     * Usado na destrui√ß√£o de chefes para um efeito cinematogr√°fico. O zoom √© revertido
     * automaticamente pelo resetCameraZoom().
     * @param {{x:number, y:number}} targetPos Posi√ß√£o do alvo em coordenadas de canvas
     * @param {number} scale Fator de escala (por exemplo 1.5)
     */
    function applyCameraZoom(targetPos, scale = 1.5) {
        const container = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        const canvasW = canvas.width;
        const canvasH = canvas.height;
        // Calcula o deslocamento necess√°rio: dist√¢ncia entre o centro do canvas e o alvo,
        // multiplicada pelo fator de escala para corrigir a transla√ß√£o durante o zoom.
        const offsetX = (canvasW / 2 - targetPos.x) * scale;
        const offsetY = (canvasH / 2 - targetPos.y) * scale;
        container.style.transition = 'transform 0.3s';
        container.style.transform = `translate(${offsetX}px, ${offsetY}px) scale(${scale})`;
    }

    /**
     * Remove qualquer transforma√ß√£o aplicada ao container de jogo, restaurando a c√¢mera.
     */
    function resetCameraZoom() {
        const container = document.getElementById('game-container');
        container.style.transition = 'transform 0.3s';
        container.style.transform = '';
    }

    /**
     * Lida com a destrui√ß√£o de um chefe (BossBlock). Aplica efeitos de c√¢mera lenta,
     * close-up, explos√£o e dano em √°rea nos blocos vizinhos. Ap√≥s a conclus√£o dos
     * efeitos, o tempo volta ao normal e a c√¢mera retorna.
     * @param {Block} boss O bloco chefe que foi destru√≠do
     */
    function handleBossDestruction(boss) {
        // Slow motion: reduz a escala de tempo durante o efeito
        gameState.timeScale = 0.4;
        // Zoom da c√¢mera focando no centro do chefe
        applyCameraZoom(boss.center, 1.6);
        // Explos√£o do chefe
        spawnBlockExplosion(boss.center);
        // Marca o chefe como destru√≠do imediatamente
        boss.health = 0;
        // Conta como bloco destru√≠do
        gameState.stats.blocksDestroyed++;
        // B√¥nus por bloco destru√≠do
        gameState.gems += 10;
        // Define faixas de dano em √°rea
        const rings = [
            { range: boss.radius * 2.5, damage: 1.0 },    // 100%
            { range: boss.radius * 4, damage: 0.75 },     // 75%
            { range: boss.radius * 5.5, damage: 0.5 },    // 50%
            { range: boss.radius * 7, damage: 0.25 },     // 25%
        ];
        gameState.blocks.forEach(block => {
            if (block === boss) return;
            if (block.health <= 0) return;
            const dx = block.center.x - boss.center.x;
            const dy = block.center.y - boss.center.y;
            const dist = Math.hypot(dx, dy);
            for (const ring of rings) {
                if (dist <= ring.range) {
                    const remaining = Math.ceil(block.health * (1 - ring.damage));
                    if (remaining <= 0) {
                        spawnBlockExplosion(block.center);
                        block.health = 0;
                        gameState.stats.blocksDestroyed++;
                        gameState.gems += 10;
                        checkMissions('blocksDestroyed');
                    } else {
                        block.health = remaining;
                        block.hitAnimation = 1;
                    }
                    break;
                }
            }
        });
        // Ap√≥s 700ms, restaura o tempo e a c√¢mera
        setTimeout(() => {
            resetCameraZoom();
            gameState.timeScale = 1;
        }, 700);
    }
    function generateNewRow() { const diffCfg = difficultyFactors[gameState.difficulty]; if (gameState.level > 0 && gameState.level % 10 === 0) { const bossHealth = Math.max(8, Math.round(gameState.level * 5 * diffCfg.healthMult)); gameState.blocks.push(new BossBlock(0, Math.floor(COLS / 2), bossHealth)); return; } let hasSpawnedGreen = false; let hasSpawnedRed = false; for (let c = 0; c < COLS; c++) { if (Math.random() < diffCfg.blockProb) { const health = Math.max(1, Math.round(gameState.level * diffCfg.healthMult * (0.8 + Math.random() * 0.4))); gameState.blocks.push(new Block(0, c, health)); } else { if (!hasSpawnedGreen && Math.random() < diffCfg.powerProb) { gameState.powerUps.push(new PowerUp(0, c, true)); hasSpawnedGreen = true; } else if (!hasSpawnedRed && Math.random() < diffCfg.redProb) { gameState.powerUps.push(new PowerUp(0, c, false)); hasSpawnedRed = true; } } } }
    function drawAll() { ctx.clearRect(0, 0, canvas.width, canvas.height); ctx.save(); ctx.scale(dpr, dpr); gameState.particles.forEach(p => { ctx.save(); ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }); gameState.blocks.forEach(b => b.draw()); gameState.powerUps.forEach(p => p.draw()); gameState.balls.forEach(b => b.draw()); if (gameState.playerTurn && !gameState.isShooting) { drawAimLine(); const startPos = grid.startPos; const radius = ballRadius; const gradient = ctx.createRadialGradient(startPos.x - radius / 3, startPos.y - radius / 3, 0, startPos.x, startPos.y, radius); gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ccc'); ctx.beginPath(); ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill(); ctx.beginPath(); ctx.arc(startPos.x - radius / 3, startPos.y - radius / 3, radius / 3, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fill(); } ctx.restore(); }
    function drawAimLine() { const startPos = grid.startPos; if (!gameState.isAiming || !gameState.aimEnd || gameState.aimEnd.y >= startPos.y || gameState.isPaused) return; const angle = Math.atan2(gameState.aimEnd.y - startPos.y, gameState.aimEnd.x - startPos.x); const length = Math.min(200, startPos.y - 50); const endX = startPos.x + Math.cos(angle) * length; const endY = startPos.y + Math.sin(angle) * length; const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endX, endY); gradient.addColorStop(0, 'rgba(255,255,255,0.8)'); gradient.addColorStop(1, 'rgba(255,255,255,0.2)'); ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y); ctx.lineTo(endX, endY); ctx.strokeStyle = gradient; ctx.lineWidth = 3; ctx.stroke(); ctx.beginPath(); ctx.arc(endX, endY, 8, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fill(); }
    function showToast(message, type = 'good') { ui.toast.textContent = message; ui.toast.style.backgroundColor = type === 'good' ? 'var(--highlight-color)' : '#d32f2f'; ui.toast.style.bottom = '20px'; setTimeout(() => { ui.toast.style.bottom = '-100px'; }, 2500); }
    function showAchievement(achievement) { ui.achvText.textContent = achievement.name; ui.achvPopup.style.top = '20px'; setTimeout(() => { ui.achvPopup.style.top = '-150px'; }, 4000); }
    const audio = { bgm: null, ctx: null, sfxGain: null, isInitialized: false, init() { if (this.isInitialized) return; this.bgm = document.getElementById('bgm-audio'); try { if (window.AudioContext) { this.ctx = new AudioContext(); this.sfxGain = this.ctx.createGain(); this.sfxGain.connect(this.ctx.destination); } } catch(e) { console.error("Web Audio API not supported", e); } this.updateVolume(); this.isInitialized = true; }, playBgm() { if (this.bgm && this.bgm.paused && gameState.bgmEnabled) { if(this.ctx && this.ctx.state === 'suspended') { this.ctx.resume(); } this.bgm.play().catch(e => console.error("BGM play failed:", e)); } }, updateVolume() { if(this.bgm) this.bgm.muted = !gameState.bgmEnabled; if(this.sfxGain) this.sfxGain.gain.value = gameState.sfxEnabled ? 0.5 : 0; }, playSfx(type) { if (!this.ctx || !gameState.sfxEnabled) return; const osc = this.ctx.createOscillator(); const gainNode = this.ctx.createGain(); osc.connect(gainNode); gainNode.connect(this.sfxGain); const now = this.ctx.currentTime; gainNode.gain.setValueAtTime(0.5, now); switch(type) { case 'hit': osc.type = 'triangle'; osc.frequency.setValueAtTime(440 + (gameState.combo * 10), now); osc.frequency.linearRampToValueAtTime(110, now + 0.2); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2); break; case 'wall': osc.type = 'sine'; osc.frequency.setValueAtTime(220, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1); break; case 'powerup': osc.type = 'square'; osc.frequency.setValueAtTime(523.25, now); osc.frequency.linearRampToValueAtTime(1046.50, now + 0.2); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3); break; case 'powerdown': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(110, now + 0.3); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4); break; case 'boss': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(80, now + 0.3); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.35); break; } osc.start(now); osc.stop(now + 0.5); }, };
    const haptic = { light: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate(10); }, medium: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate([20, 10, 20]); }, heavy: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate([60, 20, 60]); }, };
    const achievements = { _list: [], init() { const levelTargets = [1, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100]; levelTargets.forEach(l => this._list.push({ id: `L${l}`, name: `Alcan√ßar N√≠vel ${l}`, check: () => gameState.level >= l })); const hitTargets = [100, 500, 1000, 2500, 5000, 10000, 25000, 50000]; hitTargets.forEach(h => this._list.push({ id: `H${h}`, name: `Acertar blocos ${h} vezes`, check: () => gameState.stats.hits >= h })); const blockTargets = [50, 200, 500, 1000, 2500, 5000, 10000]; blockTargets.forEach(b => this._list.push({ id: `B${b}`, name: `Destruir ${b} blocos`, check: () => gameState.stats.blocksDestroyed >= b })); const bossTargets = [1, 3, 5, 10, 15, 25]; bossTargets.forEach(b => this._list.push({ id: `Boss${b}`, name: `Derrotar ${b} chefes`, check: () => gameState.stats.bossesDefeated >= b })); const skinTargets = [2, 5, 10, 15, 20, 25]; skinTargets.forEach(s => this._list.push({ id: `US${s}`, name: `Desbloquear ${s} skins`, check: () => Object.keys(gameState.unlockedSkins).length >= s })); const themeTargets = [2, 5, 10, 15, 20, 25]; themeTargets.forEach(t => this._list.push({ id: `UT${t}`, name: `Desbloquear ${t} temas`, check: () => Object.keys(gameState.unlockedThemes).length >= t })); this._list.push({ id: 'PWR100', name: 'Coletar 100 power-ups verdes', check: () => gameState.stats.powerupsGreen >= 100 }); this._list.push({ id: 'PWRD50', name: 'Coletar 50 power-downs vermelhos', check: () => gameState.stats.powerdownsRed >= 50 }); while(this._list.length < 100) { this._list.push({ id: `placeholder_${this._list.length}`, name: 'Conquista Futura', check: () => false }); } this._list = this._list.slice(0, 100); }, check() { let newUnlock = false; this._list.forEach(achv => { if (!gameState.unlockedAchv[achv.id] && achv.check()) { gameState.unlockedAchv[achv.id] = true; showAchievement(achv); audio.playSfx('powerup'); haptic.heavy(); newUnlock = true; } }); if (newUnlock) { saveProgress(); renderAchievements(); } } }; achievements.init(); const checkAchievements = achievements.check.bind(achievements);
    const SKINS = Array.from({ length: 25 }, (_, i) => ({ id: `skin_${i+1}`, color: `hsl(${(i * 360 / 25)}, 90%, 65%)`, unlockReq: () => gameState.level >= i * 2 })); const THEMES = Array.from({ length: 25 }, (_, i) => ({ id: `theme_${i+1}`, colors: { '--bg-color': `hsl(${(i * 30 + 230) % 360}, 30%, 15%)`, '--panel-bg-color': `hsl(${(i * 30 + 230) % 360}, 40%, 10%)`, '--accent-color': `hsl(${(i * 30 + 230) % 360}, 50%, 30%)`, '--highlight-color': `hsl(${(i * 30 + 30) % 360}, 90%, 60%)`, }, unlockReq: () => gameState.stats.blocksDestroyed >= i * 50 }));
    function renderCustomization() { const skinsContainer = document.getElementById('skins-container'); skinsContainer.innerHTML = ''; SKINS.forEach(skin => { const isUnlocked = gameState.unlockedSkins[skin.id] || skin.unlockReq(); if (isUnlocked && !gameState.unlockedSkins[skin.id]) { gameState.unlockedSkins[skin.id] = true; checkAchievements(); } const el = document.createElement('div'); el.className = `grid-item ${isUnlocked ? '' : 'locked'} ${gameState.selectedSkin === skin.id ? 'selected' : ''}`; el.style.backgroundColor = skin.color; el.dataset.id = skin.id; el.addEventListener('click', () => { if (isUnlocked) { applySkin(skin.id); renderCustomization(); } else { showToast('Bloqueado!', 'bad'); } }); skinsContainer.appendChild(el); }); const themesContainer = document.getElementById('themes-container'); themesContainer.innerHTML = ''; THEMES.forEach(theme => { const isUnlocked = gameState.unlockedThemes[theme.id] || theme.unlockReq(); if (isUnlocked && !gameState.unlockedThemes[theme.id]) { gameState.unlockedThemes[theme.id] = true; checkAchievements(); } const el = document.createElement('div'); el.className = `grid-item ${isUnlocked ? '' : 'locked'} ${gameState.selectedTheme === theme.id ? 'selected' : ''}`; el.style.background = `linear-gradient(45deg, ${theme.colors['--bg-color']}, ${theme.colors['--accent-color']})`; el.dataset.id = theme.id; el.addEventListener('click', () => { if (isUnlocked) { applyTheme(theme.id); renderCustomization(); } else { showToast('Bloqueado!', 'bad'); } }); themesContainer.appendChild(el); }); }
    function applySkin(skinId) { const skin = SKINS.find(s => s.id === skinId); if (skin) { document.documentElement.style.setProperty('--neon-trail-color', skin.color); gameState.selectedSkin = skinId; saveProgress(); } }
    function applyTheme(themeId) { const theme = THEMES.find(t => t.id === themeId); if (theme) { for (const [key, value] of Object.entries(theme.colors)) { document.documentElement.style.setProperty(key, value); } gameState.selectedTheme = themeId; saveProgress(); } }
    function renderAchievements() { const container = document.getElementById('achievements-container'); container.innerHTML = ''; let unlockedCount = 0; achievements._list.forEach(achv => { const isUnlocked = gameState.unlockedAchv[achv.id]; if (isUnlocked) unlockedCount++; const el = document.createElement('div'); el.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`; el.innerHTML = `<span>${achv.name}</span><span class="badge">${isUnlocked ? '‚úîÔ∏è' : 'üîí'}</span>`; container.appendChild(el); }); ui.achvCounter.textContent = `${unlockedCount}/${achievements._list.length}`; }
    function renderRanking() { const container = document.getElementById('ranking-container'); container.innerHTML = ''; if (gameState.ranking.length === 0) { container.innerHTML = '<p>Nenhum recorde ainda.</p>'; return; } gameState.ranking.forEach((entry, i) => { const el = document.createElement('div'); el.className = 'ranking-item'; el.innerHTML = `<span>#${i+1} ${entry.name}</span><span>N√≠vel ${entry.score}</span>`; container.appendChild(el); }); }
    function unlockRandomItem() { const lockedSkins = SKINS.filter(s => !gameState.unlockedSkins[s.id]); const lockedThemes = THEMES.filter(t => !gameState.unlockedThemes[t.id]); if (!lockedSkins.length && !lockedThemes.length) return; if (lockedSkins.length > 0 && (!lockedThemes.length || Math.random() < 0.5)) { gameState.unlockedSkins[lockedSkins[0].id] = true; showToast(`Nova Skin Desbloqueada!`); } else if (lockedThemes.length > 0) { gameState.unlockedThemes[lockedThemes[0].id] = true; showToast(`Novo Tema Desbloqueado!`); } checkAchievements(); saveProgress(); renderCustomization(); }
    function resizeCanvas() { dpr = window.devicePixelRatio || 1; const rect = document.body.getBoundingClientRect(); let w = rect.width; let h = rect.height; if (w / h > TARGET_AR) { w = h * TARGET_AR; } else { h = w / TARGET_AR; } canvas.style.width = `${w}px`; canvas.style.height = `${h}px`; canvas.width = w * dpr; canvas.height = h * dpr; cw = w; ch = h; const topOffset = 60; grid = { cellW: cw / COLS, gridH: (cw / COLS) * 1.05, rows: Math.floor((ch - topOffset) / ((cw / COLS) * 1.05)), topOffset: topOffset, startPos: new Vector(cw / 2, ch - 50) }; ballRadius = Math.max(6, Math.round(cw / 70)); blockRadius = (cw / COLS) * 0.45; }
    function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return new Vector((clientX - rect.left) / rect.width * cw, (clientY - rect.top) / rect.height * ch); }
    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    async function shareRecord() {
        const text = `Meu recorde no Trian-GUI-Balls √© N√≠vel ${gameState.highScore}!`;
        try {
            if (navigator.share) {
                await navigator.share({ title: 'Trian-GUI-Balls Recorde!', text: text, url: window.location.href });
                showToast('Compartilhado com sucesso!');
            } else {
                const msg = encodeURIComponent(`${text} Jogue aqui: ${window.location.href}`);
                // Fallback: abre o WhatsApp Web/app para compartilhar
                window.open(`https://api.whatsapp.com/send?text=${msg}`, '_blank');
                showToast('Link para WhatsApp gerado!');
            }
        } catch (err) {
            console.error('Erro ao compartilhar:', err);
            showToast('N√£o foi poss√≠vel compartilhar.', 'bad');
        }
    }
    function runDemo() { if (Math.random() < 0.01) { fireBalls(-Math.PI / 2 + (Math.random() - 0.5)); } }

    init();
});

// Adicionado para que a fun√ß√£o de compra seja globalmente acess√≠vel pelo onclick
function handlePurchase(itemId) {
    // Esta √© uma fun√ß√£o stub. No jogo real, voc√™ chamaria um m√©todo de um objeto de jogo.
    console.log(`Tentativa de compra do item: ${itemId}`);
    const toast = document.getElementById('toastMessage');
    toast.textContent = 'Fun√ß√£o de compra ainda n√£o implementada.';
    toast.style.backgroundColor = '#d32f2f';
    toast.style.bottom = '20px';
    setTimeout(() => { toast.style.bottom = '-100px'; }, 2500);
}

</script>

</body>
</html>
