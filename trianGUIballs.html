<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Trian-GUI-Balls (v2.2 - Efeitos Restaurados)</title>
    <style>
        :root {
            /* Variaveis de Tema (Padrão) */
            --bg-color: #1a1a2e;
            --panel-bg-color: #16213e;
            --text-color: #e0e0e0;
            --accent-color: #0f3460;
            --highlight-color: #e94560;
            --neon-trail-color: #00ffff; /* Cor neon do rastro da nova versão */
            --hud-bg-color: rgba(22, 33, 62, 0.85);
            --button-bg-color: #1f4068;
            --button-hover-bg-color: #275285;
            --locked-color: #4a4a4a;
            --font-family: 'Segoe UI', 'Roboto', 'Helvetica Neue', sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-family);
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            background-color: transparent;
            touch-action: none;
            cursor: crosshair;
        }

        #ui-container {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 100%;
            max-width: 500px;
            display: flex;
            justify-content: space-around;
            padding: 10px;
            background-color: var(--hud-bg-color);
            backdrop-filter: blur(5px);
            z-index: 10;
            font-size: 1.2rem;
            font-weight: bold;
            box-sizing: border-box;
            border-bottom: 2px solid var(--accent-color);
        }

        .hud-item {
            text-align: center;
        }
        .hud-item span {
            display: block;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            z-index: 10;
        }

        .control-button {
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: bold;
            background-color: var(--button-bg-color);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s, transform 0.1s;
        }
        .control-button:hover {
            background-color: var(--button-hover-bg-color);
        }
        .control-button:active {
            transform: scale(0.95);
        }

        /* ----- PAINEL LATERAL ----- */
        #side-panel {
            position: fixed;
            top: 0;
            right: -320px;
            width: 300px;
            height: 100%;
            background-color: var(--panel-bg-color);
            z-index: 100;
            transition: right 0.3s ease-in-out;
            box-shadow: -5px 0 15px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            border-left: 2px solid var(--accent-color);
        }
        #side-panel.open {
            right: 0;
        }

        #menu-toggle {
            position: fixed;
            top: 15px;
            right: 15px;
            z-index: 101;
            background: var(--button-bg-color);
            color: var(--text-color);
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 24px;
            cursor: pointer;
            line-height: 40px;
            text-align: center;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid var(--accent-color);
        }

        .panel-tabs {
            display: flex;
            justify-content: space-around;
            background-color: var(--accent-color);
        }
        .tab-button {
            flex-grow: 1;
            padding: 10px;
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            opacity: 0.7;
            border-bottom: 3px solid transparent;
        }
        .tab-button.active {
            opacity: 1;
            border-bottom: 3px solid var(--highlight-color);
        }

        .panel-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 15px;
        }
        .panel-section {
            display: none;
        }
        .panel-section.active {
            display: block;
        }

        .grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
        }
        .grid-item {
            aspect-ratio: 1 / 1;
            border: 2px solid var(--accent-color);
            border-radius: 8px;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
        }
        .grid-item.selected {
            border-color: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
        }
        .grid-item.locked {
            background-color: var(--locked-color);
            cursor: not-allowed;
            color: #888;
        }
        .grid-item.locked::after {
            content: '🔒';
            position: absolute;
            font-size: 2rem;
            opacity: 0.7;
        }
        
        .achievement-card {
            background-color: var(--accent-color);
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .achievement-card.unlocked {
            background-color: #2a522a;
        }
        .achievement-card .badge {
            font-size: 1.5rem;
        }

        .ranking-item {
            display: flex;
            justify-content: space-between;
            padding: 5px;
            border-bottom: 1px solid var(--accent-color);
        }

        /* ----- OVERLAYS & POPUPS ----- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 50;
            color: white;
            text-align: center;
        }

        .overlay h1 {
            font-size: 3rem;
            color: var(--highlight-color);
            text-shadow: 0 0 10px var(--highlight-color);
        }
        
        .overlay button {
             padding: 15px 30px;
            font-size: 1.2rem;
            margin: 10px;
            cursor: pointer;
            background-color: var(--button-bg-color);
            color: var(--text-color);
            border: 2px solid var(--accent-color);
            border-radius: 12px;
        }
        .overlay button:hover {
            background-color: var(--button-hover-bg-color);
        }

        #pause-overlay, #game-over-screen {
            display: none;
        }

        #toastMessage {
            position: fixed;
            bottom: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--highlight-color);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            z-index: 200;
            transition: bottom 0.5s ease-in-out;
            font-weight: bold;
        }

        #achievementPopup {
            position: fixed;
            top: -150px;
            left: 50%;
            transform: translateX(-50%);
            background-color: gold;
            color: #333;
            padding: 20px;
            border-radius: 10px;
            z-index: 200;
            text-align: center;
            border: 3px solid #ffd700;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            transition: top 0.5s ease-in-out;
        }
        #achievementPopup h3 { margin: 0 0 5px 0; }
        #achievementPopup p { margin: 0; }

        .config-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
        }
    </style>
</head>
<body>
    
    <audio id="bgm-audio" loop>
        <source src="data:audio/mpeg;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATEFN//tAwL1lAAAAAAAAAFlLAVaqg7e3+9//3//v/+//d//7////////3//f/+//5/+3/6//r/+v/7//////v//f//f/9//3//f/9//v/////9//3//f/+//3//f//f/9//3//f//f///+AAAAAExhdmc1OC40NQAAAAAAAaQAAAAAAAAAAAD/+9DEAAAu4w8AAAq4w8AAAAMANVXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dVV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dVV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXTEFNRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1eJ9" type="audio/mpeg">
    </audio>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>

        <div id="ui-container">
            <div class="hud-item">
                <span id="level">1</span>
                <span>Nível</span>
            </div>
            <div class="hud-item">
                <span id="ball-count">1</span>
                <span>Bolas</span>
            </div>
            <div class="hud-item">
                <span id="highscore">0</span>
                <span>Recorde</span>
            </div>
        </div>

        <div id="controls">
            <button id="turbo-button" class="control-button">Turbo</button>
            <button id="skip-button" class="control-button">Pular</button>
        </div>

        <div id="start-screen" class="overlay">
            <h1>Trian-GUI-Balls</h1>
            <p>Arraste para mirar, solte para atirar.</p>
            <button id="start-button">Iniciar</button>
            <button id="options-button">Opções</button>
        </div>
        
        <div id="pause-overlay" class="overlay">
            <h1>Pausado</h1>
            <button id="resume-button">Continuar</button>
            <button id="restart-button-pause">Reiniciar</button>
        </div>

        <div id="game-over-screen" class="overlay">
            <h1>Fim de Jogo</h1>
            <p>Seu Nível: <span id="final-level">0</span></p>
            <button id="restart-button-gameover">Jogar Novamente</button>
        </div>

        <div id="options-overlay" class="overlay" style="display: none; flex-direction: column;">
            <h2>Opções</h2>
            <div class="config-item" style="flex-direction: column; gap: 10px;">
                <p>Dificuldade</p>
                <div>
                    <input type="radio" id="diff-easy" name="difficulty" value="easy"><label for="diff-easy"> Fácil</label>
                    <input type="radio" id="diff-normal" name="difficulty" value="normal" checked><label for="diff-normal"> Normal</label>
                    <input type="radio" id="diff-hard" name="difficulty" value="hard"><label for="diff-hard"> Difícil</label>
                    <input type="radio" id="diff-insane" name="difficulty" value="insane"><label for="diff-insane"> Insana</label>
                </div>
            </div>
            <div class="config-item">
                <label for="sfx-toggle">Efeitos Sonoros</label>
                <input type="checkbox" id="sfx-toggle" checked>
            </div>
             <div class="config-item">
                <label for="bgm-toggle">Música</label>
                <input type="checkbox" id="bgm-toggle" checked>
            </div>
            <div class="config-item">
                <label for="vibration-toggle">Vibração (Mobile)</label>
                <input type="checkbox" id="vibration-toggle" checked>
            </div>
            <button id="save-options-button">Salvar e Reiniciar</button>
            <button id="close-options-button">Fechar</button>
        </div>


        <div id="toastMessage">Mensagem!</div>
        <div id="achievementPopup">
            <h3>🏆 Conquista Desbloqueada! 🏆</h3>
            <p id="achievement-text">Você é incrível!</p>
        </div>
    </div>
    
    <button id="menu-toggle">☰</button>
    <div id="side-panel">
        <div class="panel-header">
            <h2>Menu</h2>
        </div>
        <div class="panel-tabs">
            <button class="tab-button active" data-tab="personalization">🎨</button>
            <button class="tab-button" data-tab="achievements">🏆</button>
            <button class="tab-button" data-tab="ranking">📈</button>
            <button class="tab-button" data-tab="share">🔗</button>
        </div>
        <div class="panel-content">
            <div id="personalization" class="panel-section active">
                <h3>Skins de Bola</h3>
                <div id="skins-container" class="grid-container"></div>
                <h3 style="margin-top: 20px;">Temas</h3>
                <div id="themes-container" class="grid-container"></div>
            </div>
            <div id="achievements" class="panel-section">
                <h3>Conquistas (<span id="achv-count">0/100</span>)</h3>
                <div id="achievements-container"></div>
            </div>
            <div id="ranking" class="panel-section">
                <h3>Ranking Local</h3>
                <div id="ranking-container"></div>
                 <h3 style="margin-top: 20px;">Desafios</h3>
                 <p style="opacity: 0.6;">Em breve...</p>
            </div>
             <div id="share" class="panel-section">
                <h3>Compartilhar</h3>
                <p>Mostre seu recorde para seus amigos!</p>
                <button id="share-button" class="control-button" style="width: 100%;">Compartilhar Recorde</button>
            </div>
        </div>
    </div>


<script>
document.addEventListener('DOMContentLoaded', () => {

    // -------------------------------------------
    // 1. SETUP INICIAL E VARIÁVEIS GLOBAIS
    // -------------------------------------------

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const ui = {
        level: document.getElementById('level'),
        ballCount: document.getElementById('ball-count'),
        highscore: document.getElementById('highscore'),
        startScreen: document.getElementById('start-screen'),
        pauseOverlay: document.getElementById('pause-overlay'),
        gameOverScreen: document.getElementById('game-over-screen'),
        optionsOverlay: document.getElementById('options-overlay'),
        finalLevel: document.getElementById('final-level'),
        toast: document.getElementById('toastMessage'),
        achvPopup: document.getElementById('achievementPopup'),
        achvText: document.getElementById('achievement-text'),
        sidePanel: document.getElementById('side-panel'),
        menuToggle: document.getElementById('menu-toggle'),
        achvCounter: document.getElementById('achv-count')
    };
    
    const COLS = 7;
    const TARGET_AR = 9 / 16;
    const BASE_SPEED = 12;
    const ACCEL_PER_S = 0.01;
    const TURBO_MULT = 5;
    const FIRE_DELAY_MS = 80;
    const COLLISION_MARGIN = 1;
    const RANK_LIMIT = 20;
    const EXPLOSION_COLORS = ['#ff00ff', '#ff6600', '#39ff14', '#00ccff'];

    let gameState = {
        level: 0,
        ballCount: 1,
        balls: [],
        blocks: [],
        powerUps: [],
        particles: [],
        playerTurn: true,
        isAiming: false,
        aimStart: null,
        aimEnd: null,
        isShooting: false,
        ballsReturned: 0,
        ballsFiredThisTurn: 0,
        firstBallReturnX: null,
        isTurboActive: false,
        isPaused: false,
        isGameOver: false,
        demoMode: true,
        highScore: 0,
        difficulty: 'normal',
        stats: { hits: 0, blocksDestroyed: 0, bossesDefeated: 0, powerupsGreen: 0, powerdownsRed: 0, shotsFired: 0, levelsCleared: 0 },
        unlockedSkins: { 'skin_1': true },
        unlockedThemes: { 'theme_1': true },
        unlockedAchv: {},
        selectedSkin: 'skin_1',
        selectedTheme: 'theme_1',
        ranking: [],
        vibrationEnabled: true,
        sfxEnabled: true,
        bgmEnabled: true,
    };
    
    let cw, ch, dpr;
    let ballRadius, blockRadius, grid;

    let lastTS = 0;
    let gameLoopId;

    const difficultyFactors = {
        easy:   { blockProb: 0.5, healthMult: 0.8, powerProb: 0.15, redProb: 0.03 },
        normal: { blockProb: 0.6, healthMult: 1.0, powerProb: 0.10, redProb: 0.05 },
        hard:   { blockProb: 0.7, healthMult: 1.3, powerProb: 0.07, redProb: 0.08 },
        insane: { blockProb: 0.8, healthMult: 1.7, powerProb: 0.05, redProb: 0.12 },
    };

    // -------------------------------------------
    // 2. CLASSES DO JOGO (COM VISUAIS ATUALIZADOS)
    // -------------------------------------------

    // Vetor 2D da nova versão, com mais métodos
    class Vector {
        constructor(x = 0, y = 0) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mul(s) { return new Vector(this.x * s, this.y * s); }
        dot(v) { return this.x * v.x + this.y * v.y; }
        mag() { return Math.hypot(this.x, this.y); }
        norm() { const m = this.mag(); return m ? this.mul(1 / m) : new Vector(); }
        rotate(angle) {
            const cos = Math.cos(angle); const sin = Math.sin(angle);
            return new Vector(this.x * cos - this.y * sin, this.x * sin + this.y * cos);
        }
        distanceTo(v) { return this.sub(v).mag(); }
    }
    
    // Bola com visual atualizado
    class Ball {
        constructor(pos, vel) {
            this.pos = pos;
            this.vel = vel.norm();
            this.radius = ballRadius;
            this.active = true;
            this.timeFired = performance.now();
            this.trail = [];
            this.maxTrailLength = 8;
        }
        get speed() {
            const elapsed = (performance.now() - this.timeFired) / 1000;
            const speedScale = 1 + Math.floor(gameState.level / 25) * 0.05;
            const accel = 1 + ACCEL_PER_S * elapsed;
            const turbo = gameState.isTurboActive ? TURBO_MULT : 1;
            return BASE_SPEED * speedScale * accel * turbo;
        }
        draw() {
            const trailColor = getComputedStyle(document.documentElement).getPropertyValue('--neon-trail-color').trim();
            // Rastro neon
            ctx.globalAlpha = 1;
            for (let i = 0; i < this.trail.length; i++) {
                const alpha = (i + 1) / this.trail.length * 0.6;
                const radius = this.radius * (0.3 + (i + 1) / this.trail.length * 0.7);
                ctx.globalAlpha = alpha;
                ctx.beginPath();
                ctx.arc(this.trail[i].x, this.trail[i].y, radius, 0, Math.PI * 2);
                ctx.fillStyle = trailColor;
                ctx.fill();
            }
            ctx.globalAlpha = 1;
            // Bola com gradiente e highlight
            const gradient = ctx.createRadialGradient(
                this.pos.x - this.radius / 3, this.pos.y - this.radius / 3, 0,
                this.pos.x, this.pos.y, this.radius
            );
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(1, '#ccc');
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.pos.x - this.radius / 3, this.pos.y - this.radius / 3, this.radius / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fill();
        }
        update(dt) {
            if (!this.active) return;
            this.trail.push(new Vector(this.pos.x, this.pos.y));
            if (this.trail.length > this.maxTrailLength) this.trail.shift();

            this.pos = this.pos.add(this.vel.mul(this.speed * dt * 60));

            if (this.pos.x - this.radius < 0 || this.pos.x + this.radius > cw) {
                this.vel.x *= -1; this.pos.x = Math.max(this.radius, Math.min(cw - this.radius, this.pos.x));
                audio.playSfx('wall'); haptic.light();
            }
            if (this.pos.y - this.radius < grid.topOffset) {
                this.vel.y *= -1; this.pos.y = grid.topOffset + this.radius;
                audio.playSfx('wall'); haptic.light();
            }
            if (this.pos.y - this.radius > ch) {
                this.active = false; gameState.ballsReturned++;
                if (gameState.firstBallReturnX === null) { gameState.firstBallReturnX = this.pos.x; }
            }
        }
    }
    
    // Bloco com rotação, pulso e novo visual
    class Block {
        constructor(row, col, health) {
            this.row = row; this.col = col; this.health = health; this.maxHealth = health;
            this.sides = 3; this.radius = blockRadius;
            this.rotation = Math.random() * Math.PI * 2;
            this.rotationSpeed = 0; this.pulsePhase = Math.random() * Math.PI * 2;
            this.hitAnimation = 0; this.isBoss = false;
            this.vertices = []; this.edges = [];
            this.recalculateGeometry();
        }
        recalculateGeometry() {
            this.center = new Vector((this.col + 0.5) * grid.cellW, grid.topOffset + (this.row + 0.5) * grid.gridH);
            this.generateGeometry();
        }
        generateGeometry() {
            this.vertices = []; this.edges = [];
            const pulseRadius = this.radius + Math.sin(this.pulsePhase) * 2;
            for (let i = 0; i < this.sides; i++) {
                const ang = this.rotation + (i * 2 * Math.PI) / this.sides;
                this.vertices.push(new Vector(this.center.x + pulseRadius * Math.cos(ang), this.center.y + pulseRadius * Math.sin(ang)));
            }
            for (let i = 0; i < this.sides; i++) {
                const p1 = this.vertices[i]; const p2 = this.vertices[(i + 1) % this.sides];
                const edgeVec = p2.sub(p1); const normal = new Vector(-edgeVec.y, edgeVec.x).norm();
                this.edges.push({ p1, p2, normal });
            }
        }
        hit() {
            if (this.health <= 0) return;
            this.health--; this.hitAnimation = 1; gameState.stats.hits++;
            audio.playSfx('hit'); haptic.medium();
            if (this.health <= 0) {
                spawnBlockExplosion(this.center); gameState.stats.blocksDestroyed++;
                if (this.isBoss) {
                    gameState.stats.bossesDefeated++; gameState.ballCount++; showToast('+1 Bola!');
                    if (Math.random() < 0.5) unlockRandomItem();
                }
            }
        }
        moveDown() { this.row++; this.recalculateGeometry(); }
        update(dt) {
            this.rotation += this.rotationSpeed; this.rotationSpeed *= 0.95; // Decaimento da rotação
            this.pulsePhase += 0.05;
            if (this.hitAnimation > 0) this.hitAnimation -= dt * 5;
            this.generateGeometry();
        }
        draw() {
            const healthRatio = this.health / this.maxHealth;
            const hue = 120 * healthRatio + 60 * (1 - healthRatio);
            const saturation = 70 + this.hitAnimation * 30;
            const lightness = 40 + this.hitAnimation * 20;
            ctx.fillStyle = `hsl(${hue},${saturation}%,${lightness}%)`;
            ctx.strokeStyle = `hsl(${hue},${saturation}%,${lightness + 20}%)`;
            ctx.lineWidth = 3;
            ctx.save(); ctx.translate(2, 2); ctx.globalAlpha = 0.3;
            ctx.beginPath(); ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            ctx.closePath(); ctx.fillStyle = '#000'; ctx.fill();
            ctx.restore();
            ctx.beginPath(); ctx.moveTo(this.vertices[0].x, this.vertices[0].y);
            for (let i = 1; i < this.vertices.length; i++) ctx.lineTo(this.vertices[i].x, this.vertices[i].y);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            const fontPx = Math.max(14, Math.round(this.radius * 0.8));
            ctx.font = `700 ${fontPx}px -apple-system, BlinkMacSystemFont, Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(this.health, this.center.x + 1, this.center.y + 1);
            ctx.fillStyle = '#fff';
            ctx.fillText(this.health, this.center.x, this.center.y);
        }
    }

    class BossBlock extends Block {
        constructor(row, col, health) {
            super(row, col, health);
            this.isBoss = true; this.sides = 6;
            this.radius = blockRadius * 1.5;
            this.recalculateGeometry();
        }
        hit() { super.hit(); audio.playSfx('boss'); }
    }
    
    // PowerUp com novo visual
    class PowerUp {
        constructor(row, col, isGood = true) {
            this.row = row; this.col = col; this.isGood = isGood;
            this.radius = ballRadius * 1.6; this.collected = false;
            this.rotation = 0; this.pulsePhase = Math.random() * Math.PI * 2;
            this.recalculateGeometry();
        }
        recalculateGeometry() { this.pos = new Vector((this.col + 0.5) * grid.cellW, grid.topOffset + (this.row + 0.5) * grid.gridH); }
        moveDown() { this.pos.y += grid.gridH; }
        collect() {
            if (this.collected) return; this.collected = true;
            if (this.isGood) {
                gameState.ballCount++; gameState.stats.powerupsGreen++;
                showToast('+1 Bola!'); audio.playSfx('powerup'); haptic.heavy();
            } else {
                if (gameState.ballCount > 1) {
                    gameState.ballCount--; gameState.stats.powerdownsRed++;
                    showToast('-1 Bola!', 'bad'); audio.playSfx('powerdown'); haptic.medium();
                }
            }
            updateHUD(); checkAchievements(); saveProgress();
        }
        draw() {
            if (this.collected) return;
            this.rotation += 0.05; this.pulsePhase += 0.1;
            const pulse = 1 + Math.sin(this.pulsePhase) * 0.2;
            const currentRadius = this.radius * pulse;
            const color = this.isGood ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
            const strokeColor = this.isGood ? '#0f0' : '#f00';
            const text = this.isGood ? '+' : '-';
            // Brilho
            const gradient = ctx.createRadialGradient(this.pos.x, this.pos.y, 0, this.pos.x, this.pos.y, currentRadius * 2);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.5, color.replace('0.8', '0.4'));
            gradient.addColorStop(1, color.replace('0.8', '0'));
            ctx.fillStyle = gradient;
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, currentRadius * 2, 0, Math.PI * 2); ctx.fill();
            // Círculo principal
            ctx.beginPath(); ctx.arc(this.pos.x, this.pos.y, currentRadius, 0, Math.PI * 2);
            ctx.strokeStyle = strokeColor; ctx.lineWidth = 3; ctx.stroke();
            // Texto
            ctx.save(); ctx.translate(this.pos.x, this.pos.y); ctx.rotate(this.rotation);
            ctx.fillStyle = strokeColor; ctx.font = `700 ${currentRadius}px -apple-system, BlinkMacSystemFont, Arial`;
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 0, 0);
            ctx.restore();
        }
    }

    // -------------------------------------------
    // 3. LÓGICA DO JOGO (COM FÍSICA ATUALIZADA)
    // -------------------------------------------

    function init() {
        resizeCanvas(); loadProgress(); audio.init();
        setupEventListeners(); renderAllSidePanelTabs();
        resetGame(); gameLoop();
    }
    function resetGame() {
        const diffCfg = difficultyFactors[gameState.difficulty];
        gameState.level = 0; gameState.ballCount = diffCfg === difficultyFactors.easy ? 3 : 1;
        gameState.balls = []; gameState.blocks = []; gameState.powerUps = []; gameState.particles = [];
        gameState.playerTurn = true; gameState.isShooting = false; gameState.isGameOver = false; gameState.isPaused = false;
        ui.gameOverScreen.style.display = 'none';
        if (!gameState.demoMode) { ui.startScreen.style.display = 'none'; }
        nextLevel();
    }
    function gameLoop(timestamp) {
        if (!lastTS) lastTS = timestamp;
        const dt = Math.min(0.05, (timestamp - lastTS) / 1000);
        lastTS = timestamp;
        if (!gameState.isPaused && !gameState.isGameOver) { updateAll(dt); }
        drawAll();
        if (gameState.demoMode && gameState.playerTurn && !gameState.isShooting) { runDemo(); }
        gameLoopId = requestAnimationFrame(gameLoop);
    }
    function updateAll(dt) {
        // Lógica de partículas da nova versão
        gameState.particles = gameState.particles.filter(p => {
            p.x += p.dx * dt * 60; p.y += p.dy * dt * 60;
            p.radius *= 0.97; p.alpha -= dt * 2;
            return p.alpha > 0 && p.radius > 0;
        });
        gameState.blocks.forEach(b => b.update(dt));
        if (gameState.isShooting) {
            const substeps = gameState.isTurboActive ? TURBO_MULT : 1;
            const subDt = dt / substeps;
            for (let i = 0; i < substeps; i++) {
                gameState.balls.forEach(ball => ball.update(subDt));
                checkCollisions();
            }
            if (gameState.ballsReturned === gameState.ballsFiredThisTurn) { endTurn(); }
        }
    }
    function endTurn() {
        gameState.isShooting = false; gameState.playerTurn = true;
        grid.startPos.x = cw / 2; gameState.balls = [];
        nextLevel();
    }

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(dpr, dpr);
        // Desenho de partículas da nova versão
        gameState.particles.forEach(p => {
            ctx.save(); ctx.globalAlpha = p.alpha; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
        });
        gameState.blocks.forEach(b => b.draw());
        gameState.powerUps.forEach(p => p.draw());
        gameState.balls.forEach(b => b.draw());
        if (gameState.playerTurn && !gameState.isShooting) {
            drawAimLine();
            // Desenhar a bola na base
            const startPos = grid.startPos;
            const radius = ballRadius;
            const gradient = ctx.createRadialGradient(startPos.x - radius / 3, startPos.y - radius / 3, 0, startPos.x, startPos.y, radius);
            gradient.addColorStop(0, '#fff'); gradient.addColorStop(1, '#ccc');
            ctx.beginPath(); ctx.arc(startPos.x, startPos.y, radius, 0, Math.PI * 2); ctx.fillStyle = gradient; ctx.fill();
            ctx.beginPath(); ctx.arc(startPos.x - radius / 3, startPos.y - radius / 3, radius / 3, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'; ctx.fill();
        }
        ctx.restore();
    }
    
    function drawAimLine() {
        const startPos = grid.startPos;
        if (!gameState.isAiming || !gameState.aimEnd || gameState.aimEnd.y >= startPos.y || gameState.isPaused) return;
        const angle = Math.atan2(gameState.aimEnd.y - startPos.y, gameState.aimEnd.x - startPos.x);
        const length = Math.min(200, startPos.y - 50);
        const endX = startPos.x + Math.cos(angle) * length;
        const endY = startPos.y + Math.sin(angle) * length;
        const gradient = ctx.createLinearGradient(startPos.x, startPos.y, endX, endY);
        gradient.addColorStop(0, 'rgba(255,255,255,0.8)');
        gradient.addColorStop(1, 'rgba(255,255,255,0.2)');
        ctx.beginPath(); ctx.moveTo(startPos.x, startPos.y);
        ctx.lineTo(endX, endY); ctx.strokeStyle = gradient; ctx.lineWidth = 3; ctx.stroke();
        ctx.beginPath(); ctx.arc(endX, endY, 8, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.6)'; ctx.fill();
    }

    function nextLevel() {
        gameState.level++; gameState.stats.levelsCleared++;
        if (gameState.level > gameState.highScore) { gameState.highScore = gameState.level; }
        [...gameState.blocks, ...gameState.powerUps].forEach(e => e.moveDown());
        gameState.blocks = gameState.blocks.filter(b => b.center.y < ch);
        gameState.powerUps = gameState.powerUps.filter(p => p.pos.y - p.radius < ch && !p.collected);
        if (gameState.blocks.some(b => b.row >= grid.rows - 1)) { gameOver(); return; }
        generateNewRow(); updateHUD(); checkAchievements(); saveProgress();
    }
    function generateNewRow() {
        const diffCfg = difficultyFactors[gameState.difficulty];
        if (gameState.level > 0 && gameState.level % 10 === 0) {
            const bossHealth = Math.max(8, Math.round(gameState.level * 5 * diffCfg.healthMult));
            gameState.blocks.push(new BossBlock(0, Math.floor(COLS / 2), bossHealth));
            return;
        }
        let hasSpawnedGreen = false; let hasSpawnedRed = false;
        for (let c = 0; c < COLS; c++) {
            if (Math.random() < diffCfg.blockProb) {
                const health = Math.max(1, Math.round(gameState.level * diffCfg.healthMult * (0.8 + Math.random() * 0.4)));
                gameState.blocks.push(new Block(0, c, health));
            } else {
                if (!hasSpawnedGreen && Math.random() < diffCfg.powerProb) {
                    gameState.powerUps.push(new PowerUp(0, c, true)); hasSpawnedGreen = true;
                } else if (!hasSpawnedRed && Math.random() < diffCfg.redProb) {
                    gameState.powerUps.push(new PowerUp(0, c, false)); hasSpawnedRed = true;
                }
            }
        }
    }
    function fireBalls(angle) {
        if (!gameState.playerTurn || gameState.isShooting) return;
        gameState.playerTurn = false; gameState.isShooting = true;
        gameState.ballsReturned = 0; gameState.ballsFiredThisTurn = gameState.ballCount;
        gameState.firstBallReturnX = null; gameState.stats.shotsFired++;
        const vel = new Vector(Math.cos(angle), Math.sin(angle));
        for (let i = 0; i < gameState.ballCount; i++) {
            setTimeout(() => {
                if (gameState.isGameOver || gameState.isPaused) return;
                gameState.balls.push(new Ball(new Vector(grid.startPos.x, grid.startPos.y), vel));
            }, i * FIRE_DELAY_MS);
        }
    }
    
    // Colisão com física de rotação integrada
    function checkCollisions() {
        for (const ball of gameState.balls) {
            if (!ball.active) continue;
            for (const p of gameState.powerUps) {
                if (!p.collected && ball.pos.distanceTo(p.pos) < ball.radius + p.radius) { p.collect(); }
            }
            gameState.powerUps = gameState.powerUps.filter(p => !p.collected);
            for (const block of gameState.blocks) {
                if (ball.pos.distanceTo(block.center) > ball.radius + block.radius * 1.5) continue;
                for (const edge of block.edges) {
                    const lineVec = edge.p2.sub(edge.p1); const pointVec = ball.pos.sub(edge.p1);
                    const t = clamp(pointVec.dot(lineVec) / lineVec.dot(lineVec), 0, 1);
                    const closestPoint = edge.p1.add(lineVec.mul(t));
                    const distVec = ball.pos.sub(closestPoint); const distance = distVec.mag();
                    if (distance < ball.radius + COLLISION_MARGIN) {
                        block.hit();
                        // Lógica de rotação (torque)
                        if (!block.isBoss) { // Boss já tem rotação própria
                            const spin = ball.vel.x * edge.normal.y - ball.vel.y * edge.normal.x;
                            const direction = spin >= 0 ? 1 : -1;
                            const relVec = closestPoint.sub(block.center);
                            const torque = Math.min(1, relVec.mag() / block.radius);
                            block.rotationSpeed += torque * 0.15 * direction;
                        }
                        const dot = ball.vel.dot(edge.normal);
                        ball.vel = ball.vel.sub(edge.normal.mul(2 * dot)).norm();
                        const overlap = ball.radius + COLLISION_MARGIN - distance;
                        const pushDir = distance > 0 ? distVec.norm() : edge.normal;
                        ball.pos = ball.pos.add(pushDir.mul(overlap + 0.5));
                        goto_next_ball_check:;
                    }
                }
            }
            gameState.blocks = gameState.blocks.filter(b => b.health > 0);
        }
    }
    // Explosão de partículas da nova versão
    function spawnBlockExplosion(position) {
        const count = 12;
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 2 + Math.random() * 2;
            const dx = Math.cos(angle) * speed; const dy = Math.sin(angle) * speed;
            const radius = 3 + Math.random() * 3;
            const color = EXPLOSION_COLORS[Math.floor(Math.random() * EXPLOSION_COLORS.length)];
            gameState.particles.push({ x: position.x, y: position.y, dx, dy, radius, alpha: 1, color });
        }
    }

    function gameOver() {
        if (gameState.isGameOver) return; gameState.isGameOver = true;
        ui.gameOverScreen.style.display = 'flex'; ui.finalLevel.textContent = gameState.level;
        cancelAnimationFrame(gameLoopId);
        setTimeout(() => {
            const name = prompt(`Fim de Jogo! Seu nível foi ${gameState.level}. Digite seu nome:`, "Jogador");
            if (name) {
                gameState.ranking.push({ name, score: gameState.level });
                gameState.ranking.sort((a, b) => b.score - a.score);
                gameState.ranking = gameState.ranking.slice(0, RANK_LIMIT);
                saveProgress(); renderRanking();
            }
        }, 500);
    }
    function togglePause() {
        gameState.isPaused = !gameState.isPaused;
        ui.pauseOverlay.style.display = gameState.isPaused ? 'flex' : 'none';
        if (!gameState.isPaused) {
            lastTS = performance.now(); gameLoop(lastTS);
            audio.playBgm();
        } else {
            cancelAnimationFrame(gameLoopId); 
            if(audio.bgm) audio.bgm.pause();
        }
    }

    // O restante do código (Persistência, UI, Eventos, Conquistas, etc.) permanece o mesmo da v2.1
    // ... (As funções saveProgress, loadProgress, setupEventListeners, updateHUD, showToast, etc., são omitidas aqui por brevidade, mas estão no código final)

    function saveProgress() { try { const progress = { highScore: gameState.highScore, selectedSkin: gameState.selectedSkin, selectedTheme: gameState.selectedTheme, unlockedSkins: gameState.unlockedSkins, unlockedThemes: gameState.unlockedThemes, unlockedAchv: gameState.unlockedAchv, vibrationEnabled: gameState.vibrationEnabled, sfxEnabled: gameState.sfxEnabled, bgmEnabled: gameState.bgmEnabled, difficulty: gameState.difficulty, stats: gameState.stats, ranking: gameState.ranking, }; localStorage.setItem('ballz_progress_v3', JSON.stringify(progress)); } catch (e) { console.error("Erro ao salvar progresso:", e); } }
    function loadProgress() { try { const progressStr = localStorage.getItem('ballz_progress_v3'); if (progressStr) { Object.assign(gameState, JSON.parse(progressStr)); } document.getElementById('vibration-toggle').checked = gameState.vibrationEnabled; document.getElementById('sfx-toggle').checked = gameState.sfxEnabled; document.getElementById('bgm-toggle').checked = gameState.bgmEnabled; document.querySelector(`input[name="difficulty"][value="${gameState.difficulty}"]`).checked = true; applyTheme(gameState.selectedTheme); updateHUD(); } catch (e) { console.error("Erro ao carregar progresso:", e); } }
    function setupEventListeners() { window.addEventListener('resize', resizeCanvas); const startAim = (e) => { if (!gameState.playerTurn || gameState.isPaused || gameState.isGameOver) return; audio.playBgm(); e.preventDefault(); gameState.isAiming = true; gameState.aimStart = getEventPos(e); }; const moveAim = (e) => { if (!gameState.isAiming) return; e.preventDefault(); gameState.aimEnd = getEventPos(e); }; const endAim = (e) => { if (!gameState.isAiming) return; e.preventDefault(); gameState.isAiming = false; const start = grid.startPos; const end = gameState.aimEnd || gameState.aimStart; if (end && end.y < start.y) { const angle = Math.atan2(end.y - start.y, end.x - start.x); fireBalls(angle); } gameState.aimEnd = null; }; canvas.addEventListener('mousedown', startAim); canvas.addEventListener('mousemove', moveAim); canvas.addEventListener('mouseup', endAim); canvas.addEventListener('mouseleave', endAim); canvas.addEventListener('touchstart', startAim, { passive: false }); canvas.addEventListener('touchmove', moveAim, { passive: false }); canvas.addEventListener('touchend', endAim); canvas.addEventListener('touchcancel', endAim); document.getElementById('start-button').addEventListener('click', () => { gameState.demoMode = false; ui.startScreen.style.display = 'none'; audio.playBgm(); resetGame(); }); const turboButton = document.getElementById('turbo-button'); turboButton.addEventListener('mousedown', () => gameState.isTurboActive = true); turboButton.addEventListener('mouseup', () => gameState.isTurboActive = false); turboButton.addEventListener('mouseleave', () => gameState.isTurboActive = false); turboButton.addEventListener('touchstart', (e) => { e.preventDefault(); gameState.isTurboActive = true; }); turboButton.addEventListener('touchend', () => gameState.isTurboActive = false); document.getElementById('skip-button').addEventListener('click', () => { if (gameState.isShooting) endTurn(); }); document.addEventListener('keydown', (e) => { if (e.key === 'Escape' || e.key === 'p') { if (!gameState.isGameOver && ui.startScreen.style.display === 'none') togglePause(); } }); document.getElementById('resume-button').addEventListener('click', togglePause); document.getElementById('restart-button-pause').addEventListener('click', () => { togglePause(); resetGame(); }); document.getElementById('restart-button-gameover').addEventListener('click', resetGame); document.getElementById('options-button').addEventListener('click', () => ui.optionsOverlay.style.display = 'flex'); document.getElementById('close-options-button').addEventListener('click', () => ui.optionsOverlay.style.display = 'none'); document.getElementById('save-options-button').addEventListener('click', () => { gameState.difficulty = document.querySelector('input[name="difficulty"]:checked').value; gameState.sfxEnabled = document.getElementById('sfx-toggle').checked; gameState.bgmEnabled = document.getElementById('bgm-toggle').checked; gameState.vibrationEnabled = document.getElementById('vibration-toggle').checked; audio.updateVolume(); saveProgress(); ui.optionsOverlay.style.display = 'none'; resetGame(); }); ui.menuToggle.addEventListener('click', () => ui.sidePanel.classList.toggle('open')); document.querySelectorAll('.tab-button').forEach(button => { button.addEventListener('click', () => { const tabId = button.dataset.tab; document.querySelectorAll('.tab-button, .panel-section').forEach(el => el.classList.remove('active')); button.classList.add('active'); document.getElementById(tabId).classList.add('active'); }); }); document.getElementById('share-button').addEventListener('click', shareRecord); }
    function updateHUD() { ui.level.textContent = gameState.level; ui.ballCount.textContent = gameState.ballCount; ui.highscore.textContent = gameState.highScore; }
    function showToast(message, type = 'good') { ui.toast.textContent = message; ui.toast.style.backgroundColor = type === 'good' ? 'var(--highlight-color)' : '#d32f2f'; ui.toast.style.bottom = '20px'; setTimeout(() => { ui.toast.style.bottom = '-100px'; }, 2500); }
    function showAchievement(achievement) { ui.achvText.textContent = achievement.name; ui.achvPopup.style.top = '20px'; setTimeout(() => { ui.achvPopup.style.top = '-150px'; }, 4000); }
    const audio = { bgm: null, ctx: null, sfxGain: null, isInitialized: false, init() { if (this.isInitialized) return; this.bgm = document.getElementById('bgm-audio'); if (window.AudioContext) { this.ctx = new AudioContext(); this.sfxGain = this.ctx.createGain(); this.sfxGain.connect(this.ctx.destination); } this.updateVolume(); this.isInitialized = true; }, playBgm() { if (this.bgm && this.bgm.paused && gameState.bgmEnabled) { if(this.ctx && this.ctx.state === 'suspended') { this.ctx.resume(); } this.bgm.play().catch(e => console.error("BGM play failed:", e)); } }, updateVolume() { if(this.bgm) this.bgm.muted = !gameState.bgmEnabled; if(this.sfxGain) this.sfxGain.gain.value = gameState.sfxEnabled ? 0.5 : 0; }, playSfx(type) { if (!this.ctx || !gameState.sfxEnabled) return; const osc = this.ctx.createOscillator(); const gainNode = this.ctx.createGain(); osc.connect(gainNode); gainNode.connect(this.sfxGain); const now = this.ctx.currentTime; gainNode.gain.setValueAtTime(0.5, now); switch(type) { case 'hit': osc.type = 'triangle'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(110, now + 0.2); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.2); break; case 'wall': osc.type = 'sine'; osc.frequency.setValueAtTime(220, now); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.1); break; case 'powerup': osc.type = 'square'; osc.frequency.setValueAtTime(523.25, now); osc.frequency.linearRampToValueAtTime(1046.50, now + 0.2); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.3); break; case 'powerdown': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(440, now); osc.frequency.linearRampToValueAtTime(110, now + 0.3); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4); break; case 'boss': osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); osc.frequency.linearRampToValueAtTime(80, now + 0.3); gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.35); break; } osc.start(now); osc.stop(now + 0.5); }, };
    const haptic = { light: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate(10); }, medium: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate([20, 10, 20]); }, heavy: () => { if (gameState.vibrationEnabled && navigator.vibrate) navigator.vibrate([60, 20, 60]); }, };
    const achievements = { _list: [], init() { const levelTargets = [1, 5, 10, 15, 20, 25, 30, 40, 50, 75, 100]; levelTargets.forEach(l => this._list.push({ id: `L${l}`, name: `Alcançar Nível ${l}`, check: () => gameState.level >= l })); const hitTargets = [100, 500, 1000, 2500, 5000, 10000, 25000, 50000]; hitTargets.forEach(h => this._list.push({ id: `H${h}`, name: `Acertar blocos ${h} vezes`, check: () => gameState.stats.hits >= h })); const blockTargets = [50, 200, 500, 1000, 2500, 5000, 10000]; blockTargets.forEach(b => this._list.push({ id: `B${b}`, name: `Destruir ${b} blocos`, check: () => gameState.stats.blocksDestroyed >= b })); const bossTargets = [1, 3, 5, 10, 15, 25]; bossTargets.forEach(b => this._list.push({ id: `Boss${b}`, name: `Derrotar ${b} chefes`, check: () => gameState.stats.bossesDefeated >= b })); const skinTargets = [2, 5, 10, 15, 20, 25]; skinTargets.forEach(s => this._list.push({ id: `US${s}`, name: `Desbloquear ${s} skins`, check: () => Object.keys(gameState.unlockedSkins).length >= s })); const themeTargets = [2, 5, 10, 15, 20, 25]; themeTargets.forEach(t => this._list.push({ id: `UT${t}`, name: `Desbloquear ${t} temas`, check: () => Object.keys(gameState.unlockedThemes).length >= t })); this._list.push({ id: 'PWR100', name: 'Coletar 100 power-ups verdes', check: () => gameState.stats.powerupsGreen >= 100 }); this._list.push({ id: 'PWRD50', name: 'Coletar 50 power-downs vermelhos', check: () => gameState.stats.powerdownsRed >= 50 }); while(this._list.length < 100) { this._list.push({ id: `placeholder_${this._list.length}`, name: 'Conquista Futura', check: () => false }); } this._list = this._list.slice(0, 100); }, check() { let newUnlock = false; this._list.forEach(achv => { if (!gameState.unlockedAchv[achv.id] && achv.check()) { gameState.unlockedAchv[achv.id] = true; showAchievement(achv); audio.playSfx('powerup'); haptic.heavy(); newUnlock = true; } }); if (newUnlock) { saveProgress(); renderAchievements(); } } }; achievements.init(); const checkAchievements = achievements.check.bind(achievements);
    const SKINS = Array.from({ length: 25 }, (_, i) => ({ id: `skin_${i+1}`, color: `hsl(${(i * 360 / 25)}, 90%, 65%)`, unlockReq: () => gameState.level >= i * 2 })); const THEMES = Array.from({ length: 25 }, (_, i) => ({ id: `theme_${i+1}`, colors: { '--bg-color': `hsl(${(i * 30 + 230) % 360}, 30%, 15%)`, '--panel-bg-color': `hsl(${(i * 30 + 230) % 360}, 40%, 10%)`, '--accent-color': `hsl(${(i * 30 + 230) % 360}, 50%, 30%)`, '--highlight-color': `hsl(${(i * 30 + 30) % 360}, 90%, 60%)`, }, unlockReq: () => gameState.stats.blocksDestroyed >= i * 50 }));
    function renderCustomization() { const skinsContainer = document.getElementById('skins-container'); skinsContainer.innerHTML = ''; SKINS.forEach(skin => { const isUnlocked = gameState.unlockedSkins[skin.id] || skin.unlockReq(); if (isUnlocked && !gameState.unlockedSkins[skin.id]) { gameState.unlockedSkins[skin.id] = true; checkAchievements(); } const el = document.createElement('div'); el.className = `grid-item ${isUnlocked ? '' : 'locked'} ${gameState.selectedSkin === skin.id ? 'selected' : ''}`; el.style.backgroundColor = skin.color; el.dataset.id = skin.id; el.addEventListener('click', () => { if (isUnlocked) { applySkin(skin.id); renderCustomization(); } else { showToast('Bloqueado!', 'bad'); } }); skinsContainer.appendChild(el); }); const themesContainer = document.getElementById('themes-container'); themesContainer.innerHTML = ''; THEMES.forEach(theme => { const isUnlocked = gameState.unlockedThemes[theme.id] || theme.unlockReq(); if (isUnlocked && !gameState.unlockedThemes[theme.id]) { gameState.unlockedThemes[theme.id] = true; checkAchievements(); } const el = document.createElement('div'); el.className = `grid-item ${isUnlocked ? '' : 'locked'} ${gameState.selectedTheme === theme.id ? 'selected' : ''}`; el.style.background = `linear-gradient(45deg, ${theme.colors['--bg-color']}, ${theme.colors['--accent-color']})`; el.dataset.id = theme.id; el.addEventListener('click', () => { if (isUnlocked) { applyTheme(theme.id); renderCustomization(); } else { showToast('Bloqueado!', 'bad'); } }); themesContainer.appendChild(el); }); }
    function applySkin(skinId) { const skin = SKINS.find(s => s.id === skinId); if (skin) { document.documentElement.style.setProperty('--neon-trail-color', skin.color); gameState.selectedSkin = skinId; saveProgress(); } }
    function applyTheme(themeId) { const theme = THEMES.find(t => t.id === themeId); if (theme) { for (const [key, value] of Object.entries(theme.colors)) { document.documentElement.style.setProperty(key, value); } gameState.selectedTheme = themeId; saveProgress(); } }
    function renderAchievements() { const container = document.getElementById('achievements-container'); container.innerHTML = ''; let unlockedCount = 0; achievements._list.forEach(achv => { const isUnlocked = gameState.unlockedAchv[achv.id]; if (isUnlocked) unlockedCount++; const el = document.createElement('div'); el.className = `achievement-card ${isUnlocked ? 'unlocked' : ''}`; el.innerHTML = `<span>${achv.name}</span><span class="badge">${isUnlocked ? '✔️' : '🔒'}</span>`; container.appendChild(el); }); ui.achvCounter.textContent = `${unlockedCount}/${achievements._list.length}`; }
    function renderRanking() { const container = document.getElementById('ranking-container'); container.innerHTML = ''; if (gameState.ranking.length === 0) { container.innerHTML = '<p>Nenhum recorde ainda.</p>'; return; } gameState.ranking.forEach((entry, i) => { const el = document.createElement('div'); el.className = 'ranking-item'; el.innerHTML = `<span>#${i+1} ${entry.name}</span><span>Nível ${entry.score}</span>`; container.appendChild(el); }); }
    function renderAllSidePanelTabs() { renderCustomization(); renderAchievements(); renderRanking(); }
    function unlockRandomItem() { const lockedSkins = SKINS.filter(s => !gameState.unlockedSkins[s.id]); const lockedThemes = THEMES.filter(t => !gameState.unlockedThemes[t.id]); if (!lockedSkins.length && !lockedThemes.length) return; if (lockedSkins.length > 0 && (!lockedThemes.length || Math.random() < 0.5)) { gameState.unlockedSkins[lockedSkins[0].id] = true; showToast(`Nova Skin Desbloqueada!`); } else if (lockedThemes.length > 0) { gameState.unlockedThemes[lockedThemes[0].id] = true; showToast(`Novo Tema Desbloqueado!`); } checkAchievements(); saveProgress(); renderCustomization(); }
    function resizeCanvas() { dpr = window.devicePixelRatio || 1; const rect = document.body.getBoundingClientRect(); let w = rect.width; let h = rect.height; if (w / h > TARGET_AR) { w = h * TARGET_AR; } else { h = w / TARGET_AR; } canvas.style.width = `${w}px`; canvas.style.height = `${h}px`; canvas.width = w * dpr; canvas.height = h * dpr; cw = w; ch = h; const topOffset = 60; grid = { cellW: cw / COLS, gridH: (cw / COLS) * 1.05, rows: Math.floor((ch - topOffset) / ((cw / COLS) * 1.05)), topOffset: topOffset, startPos: new Vector(cw / 2, ch - 50) }; ballRadius = Math.max(6, Math.round(cw / 70)); blockRadius = (cw / COLS) * 0.45; }
    function getEventPos(e) { const rect = canvas.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return new Vector((clientX - rect.left) / rect.width * cw, (clientY - rect.top) / rect.height * ch); }
    function clamp(val, min, max) { return Math.max(min, Math.min(max, val)); }
    function hexToRgb(hex) { let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : '0, 255, 255'; }
    async function shareRecord() { const text = `Meu recorde no Trian-GUI-Balls é Nível ${gameState.highScore}!`; try { if (navigator.share) { await navigator.share({ title: 'Trian-GUI-Balls Recorde!', text: text, url: window.location.href }); showToast('Compartilhado com sucesso!'); } else if (navigator.clipboard) { await navigator.clipboard.writeText(`${text} Jogue aqui: ${window.location.href}`); showToast('Recorde copiado!'); } else { throw new Error("API não disponível."); } } catch (err) { console.error('Erro ao compartilhar:', err); showToast('Não foi possível compartilhar.', 'bad'); } }
    function runDemo() { if (Math.random() < 0.01) { fireBalls(-Math.PI / 2 + (Math.random() - 0.5)); } }
    init();
});
</script>

</body>
</html>